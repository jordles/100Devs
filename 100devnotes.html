<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-08">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="./styles.css">
    </head>
    <body>
        <fieldset id="class-01">
            <legend>Class 01</legend>
            <section id = "Coding">
            <h2>What is the Internet</h2>
                <p>Client-Server Model - client can make requests and server can serve them with a response<br>
                    frontend dev is client-end developers <br>
                    backend dev is server-end developers <br>
                    fullstack is both :3
                </p>
                <p>There are actually Internet cables around the world through the ocean floors, that make the client-server exchange possible. <br>
                These cables consist of 8 fiber wires, each fiber capable of transmitting 53 terabytes per sec</p>
                <p>bounce-rate - the rate is which people bounce from a website. The limit is 3 seconds for the client to make a request to the server and the server to fulfill and send the product back</p>
                <ul>Where do these client requests go? : 
                    <li>ISP - Internet Service Providers - they connect to your business place by giving us access to their fibers that connect to the big internet cables around the world</li>
                    <li>DNS - Domain Name System - it translates domain names (url) to IP addresses which our server is able to use and send/load data back to the client</li>
                </ul>
                <p>HTTP - Hypertext Transcript Protocol with TCP/IP - we are sending requests and responses through this protocol</p>
                <p>HTTPS - Hypertext Transcript Protocol Security - added security and encryption to protect requests and responses from the public</p>
                <p>VPN - Virtual Private Network - a computer that makes a request on the client's behalf, keeping anonymity <br>
                    The flow would be: Client makes a request that is encrypted > ISP > DNS > VPN : who decrypts and makes the request on your behalf
                </p>
            <hr>
            <p>Syntax - spelling and grammer rules</p>
            <h2>Structure of The Golden Rule (separation of concerns - organizes content)</h2>
                <p>HTML - Content/Structure/Backbone of our websites</p>
                <p>CSS - Style</p>
                <p>JS - Behavior/Interaction</p>
                <!--HTML and CSS are markup languages-->
            <hr>

            <h2>HTML5 - new biggest content: video, audio, canvas, geolocation, websockets (open peer to peer connections)</h2>
                <p>W3C - a standardized world wide web that have in common with all browsers</p>
                <p>HTML Syntax - consists of opening and closing tags with a tag name. <br>
                    We also have attributes that have values that do different things and the text or content inside the tags
                </p>
            </section>
            

            <h1>Homework</h1>
            <h2>Learning How to Learn</h2>
                <p>Focused(linear path focused based on knowledge known, like step by step) and Diffused Mode (used for new ideas or approaches)</p>
                <p>it uses a pinball analogy, with focused mode have more pins and closer in proximity to represent thoughts are more concentrated on one area before getting the solution. <br>
                    Diffused mode is a way of thinking more open-minded with your pins more spaced out so the concentration is more spread out and allows more freer thoughts with less intensity while maintaining some focus on your topic. <br>
                    Focused mode - a direct approach to solving problems using rational, sequential, analytical approaches. It is associated with concentrating abilities of the brain's prefrontal cortex, located right behind your forehead. <br>
                    the mode uses the 'octopus of attention' which describes slipping tentacles slipping into the 4 slots of working memory when necessary, to help make connections to information in the various parts of the brain. <br>
                    Working memory is the part of your memory that has to do with what you are immediately and consciously processing in your mind. <br>
                    Diffused mode- The brain makes random connections in a relaxed fashion. 
                    </outcome>
                    <pre>
                        flashlight set so that it casts its light very broadly, but not very strongly in any one area. 
                        (As opposed to the focused mode, which would have its light cast very strongly in a single area, but very weakly everywhere else.)
                    </pre>
                </p>
                <p>When you learn something new, new synapses are formed on the dendrites of the neurons in your brain</p>
            <hr>

            <h2>Procrastination, Memory, and Sleep </h2>
                <p>Pomodoro - a technique that encourages you to focus and study within a timer, then take a break after</p>
                <p>Long term memory vs working memory <br>
                    short term/working memory is like an inefficient blackboard and must be practiced over and over to be long term <br>
                    Long term memories is like a storage warehouse <br>
                    When you learn something new, you use youre working memory, which is capable of being long-term memory.
                </p>
                <p>There are 4 slots in the working memory, that are located behind the forehead, known as the prefrontal cortex</p>
                <p>Using diffused mode thinking, makes intentional connections with various parts of the brain instead</p>

                <p>spaced-repetition - a technique to space out repetition for studying through multiple days, instead of cramming</p>
                <p>being awake creates toxins, however when you sleep brain cells shrink and wash those toxins out. So sleeping can help the brain keep healthy</p>
            <hr>

            <h2>Chunking</h2>
                <p>When stressed your focused learning will suffer</p>
                <p>Chunks are pieces of information that are bound/group by meaning or use.</p>
                <p>Chunks are a network of neurons that are used to firing together</p>
                <p>Chunks can form from focused practice and repetition, the creation of strong memory traces</p>
                <p>Once you chunk(the main idea), you likely wont need to remember all the little underlying details</p>
                <p>using worked-out example might not be the best to form chunks because its too easy to focus too much on an individual step instead of observing the whole picture (connection between the steps)</p>
                <p>'Understanding' is a superglue that that helps hold underlying memory traces together</p>

                <ul>Steps to chunk:
                    <li>focused mode thinking on the chunk information (no distraction or multitasking, because they can use up the limited slots in your working memory)</li>
                    <li>understand the basic idea of the topic</li>
                    <li>do the problem, to prove your understanding</li>
                    <li>gaining content, means knowing when and how to use this chunk with practice</li>
                    <li>context is where top down(big picture) and bottom up learning(chunking) meet</li>
                    <li>top down(big picture) process allows you to see where what you are learning fits in</li>

                    <li>TO SUM UP: Focused Attention, Understanding, Practice </li>
                </ul>
                <p>Once a concept is chunked, it only takes one slot in working memory</p>
                <p>studies show simply practicing and recalling first is much more productive in learning that just rereading the material</p>
                <p>Recall - the mental retrieval of the key ideas is the best way to chunk and build 'neural hooks' or deeply engrain</p>
                <p>Often recalling / studying in a different place is better than constantly studying in the same place <br>
                because subconsciously you will associate your surroundings with the learning material, which can affect your memory to access them</p>
            
                <h2>Illusions of Competence: thinking youre learning, but youre actually not</h2>
                    <p>When you think seeing the solution helps you know the solution, but in reality you haven't thought through to enable neural circuitry </p>
                    <p>try highlighting main ideas before doing it everywhere, as that can convince yourself you have the concept in your memory to recall later</p>
                    <p>persistent rereading is another version of Illusions of Competence, convincing students that the material is in their mind, <br>
                        when recalling is a much more effective way to learn before rereading
                    </p>
                    <p>Mistakes help catch illusions of competence</p>
                    <p>Use deliberate practice to strengthen what you know at a higher level</p>

                <h2>Retrieval Practice:</h2>
                    <p>When you learn something, you create links in long-term memory. The process of repeatedly retrieving these links, is what strengthens them</p>
                    <p>The best way to use retrieval practice is through flashcards</p>
            <hr>

            <h2>Seeing the Bigger Picture</h2>
                <ul>Neuromodulators are chemicals that influence how a neuron responds with other neurons: <br>
                    <li>acetylcholine - formed for focused learning when you are paying close attention. <br>
                        These kinds of neurons activate circuits in synapsis that lead to long-term memory
                    </li>
                    <li>dopamine -controls our motivation, found in neurons on our brain stem (basal ganglia). <br>
                        They control reward learning and affects decision-making, and it received upon getting an unexpected reward. <br>
                        Dopamine helps motivation by placing future rewards as a goal, instead of immediate ones. It follows a promise and reward system <br>
                        A lack of dopamine neurons = lack of motivation and anhedonia - loss in interest in things that once gave pleasure. <br>
                        A severe loss of dopamine neurons causes resting tremor, slowless, rigidity, that is Parkinson's disease. <br>
                        Having no dopamine neurons can lead to catatonia. A complete lack of any movement. </li>
                    <li>serotonin - affects social life, closely linked to risk-taking behavior. </li>
                </ul>
                <p>The amygdala is the major center for cognition and emotion is located. Your emotions affect your memory and learning.</p>
                <hr>

                <p>Transfer - Chunks can be related/connect to other chunks that helps you learn more easily about chunks in different areas, and it helps you learn new concepts through chunks</p>
                <p>You brain can be thought of having a library of neural patterns/ chunks, and we can use diffuse mode thinking to help connect 2 or more chunks together to solve novel problems.  </p>

                <ul>Two ways to solve problems:
                    <li>sequential step-by-step reasoning - deliberately taking steps toward the solution; involves focused mode thinking</li>
                    <li>holistic intuition - linking several different thoughts; involves diffused mode thinking. <br>
                        Most difficult problems or concepts are grasped through intuition, because new ideas make a leap away from what you're familiar with, when can then be verified with focused mode thinking
                    </li>
                </ul>
                <p>Overlearning - continuing to practice after youve mastered what you can. This can be a good thing for automaticity, actions that becomes unconscious that its automatic <br>
                    Be careful of repetitive overlearning however, as this can be useless and bring about an illusion of competence when the material seems easy
                </p>
                <p>Deliberate practice - focusing on more difficult behavior </p>
                <p>Einstellung - initial thoughts or already formed chunks or neural pattern may prevent a better solution or idea from being found.</p>
                <p>Interleaving - practice jumping back and forth with problems and situations that require different techniques or strategies or variations. Helps you know when to use your techniques and learn more deeply. <br>
                    While spaced-repetition builds strong neural patterns, interleaving builds flexibility and creativity. 
                </p>
            <h2>Procrastination</h2>
                <p>Procrastination is like addiction - it offers excitement and relief from boring situations</p>
                <p>there are tasks where your brain goes 'zombie mode' where your brain is only semi-aware of the tasks it is doing (chunking can become habits) <br>
                    Or its a relaxed state your mind enters when you are performing common and habitual tasks<br>
                    You dont have to do focused mode thinking when you are performing a habit, it saves energy.
                </p>
                <ul>How Habits Form: 
                    <li>The cue - triggers 'zombie mode', a reaction </li>
                    <li>The routine - 'zombie mode', the actions you take when you receive a cue</li>
                    <li>the reward - habits continue because our cues cause the routines that eventually reward us</li>
                    <li>the belief - habits have power because of your belief in them. Your habits are based on your belief</li>

                    <li>finding good study habits that reward us is great for countering against procrastination</li>
                </ul>

                <p>Learn to focus on the process not the product</p>
                <p>Process- the flow of time and habits and action associated with that flow of time (steps to an outcome)</p>
                <p>Product - your outcome </p>
                <p>You prevent procrastination focus less on product and more on doing the process (develop habits that also complete the tasks you hate doing</p>
                <p>You will put less pressure on finishing a task and rather go through the flow of a process or a habit instead</p>
                <hr>

                <p>A trick to overriding a habit it to look to change your reaction to a cue </p>
                <p>The only place you need to apply willpower is to change your reaction to the cue</p>

                <ul>Habits through the lens of Procrastination
                    <li>The cue - location, time, how you feel, reactions</li>
                    <li>the routine - this is the reaction point where you must actively focus on rewiring your old habit - have a plan</li>
                    <li>the reward - once your brain expects the reward is when the rewiring takes place and allows you to form new habits</li>
                    <li>the belief - your beliefs can change your views and prevent procrastination</li>
                </ul>
                
                <p>Keep a weekly list of key tasks, with daily to do lists written the evening before because research show your subconscious will follow through with it better  </p>
                <p>Writing down tasks, helps free up working memory </p>
                <p>Writing the next day's task list before you go to sleep will help you to be able to complete the items on your task list the next day.</p>
            
                <ul>Summary:
                    <li>Keep a planner journal</li>
                    <li>Commit yourself to certain routines and tasks each day</li>
                    <li>delay rewards until you finish the task</li>
                    <li>Watch for procrastination cues</li>
                    <li>gain trust in your new system</li>
                    <li>have backup plans for when you still procrastinate</li>
                    <li>get the hardest negative task you dont want to do out of the way</li>
                </ul>
            <hr>
            <h2>Memory</h2>
                <p>Visual memory system in humans, vast and large in the brain, <br>
                    Images are important and contribute to memory because the images connect directly to your right brain's visual spacial centers. <br>
                    You can build stronger neural hooks by involving the senses with your memory. 
                </p>
                <p>The hippocampus is an important part of the brain for learning new things and memories of facts and events</p>
                <p>The lack of a hippocampus causes a process called memory consolidation (in which memories that are not set in stone in your memory are erased)</p>
                <p>Memories are living, breathing parts of the brain that are changing all the time </p>
                <p>reconsolidation - whenever you recall a memory and it changes by going from active state to inactive state in the long term memory <br>
                    It also occurs during sleep. 
                </p>
                <p>Consolidation - the process of taking memory from short term to long term </p>
                <p>Reactivation - the process of recalling a memory from long-term (so it went from an inactive state to an active one)</p>

                <p>In brains, there are supporting cells called glial cells. Astrocytes glial cells are the most abundant and provide nutrients to the neurons</p>
                
                <p>You can create meaningful groups using techniques like mnemonics or acronyms to make it easier to study with.</p>
                <p>Memory Palace technique - remember through places and writing on them like notepads,  useful for remembering unrelated items by associating each item with a different physical part of a place. <br>
                    It utilizes our visual & spatial memory systems and helps move information to long term. (its like an object with key value pairs, you use a key to find the value easily) 
                </p>
            
                <ul>Summary
                    Chunking Concepts:
                    <li>long-term memory, storage warehouse, practice and repeat to retrieve more easily, utilize spaced repetition</li>
                    <li>working-memory - a blackboard that fades quickly, 4 items in working memory, you can compact ideas to make larger chunks that take up less space in your working memory.</li>
                    <li>Visual and Spatial memory systems </li>
                    <li>meaningful groups & memory palace technique (easily simplify and chunk ideas and memories)</li>
                </ul>
            <hr>

            <h2>Renaissance Learning and Unlocking Your Potential </h2>
                <p>You can become a better learner by exercising, more effective than drugs.</p>
                <p>The visual cortex reaches maturity in childhood</p>
                <p>prefrontal cortex is the last to mature in the brain, involves complex analysis, social behavior, decision-making, and planning</p>

                <p>Knowledge collapse can occur when something that made sense to you is now confusing. This is a sign your mind is restructuring and building a firmer foundation of your understanding.</p>
        
                <p>Metaphor/Analogy - Easy way to remember and understand. The more visual the better. They describe simple ideas that relate to each other. <br>
                They usually give a physical understanding of the central idea behind the process or concept you want to understand. <br>
                They are also useful for getting out of Einstellung. They can make connections to neural structures that are already there</p>
                
                <h2>The Imposter Syndrome</h2>
                    <p>Everyone has different gifts, and imposter syndrome and inhibit you from doing your very best at your pace</p>
                    <p>people learn better by trying to make sense out of the information they perceive</p>
                    <p>having a smaller working memory means you can generalize your learning into more creative combinations. </p>
                
                <h2>Changing your Thoughts</h2>
                <p>Practice strengthens and reinforces connections between different brain regions</p>
                <p>People can enhance the development of their neuronal circuits by practicing thoughts that use those neurons</p>
                <p>We can make significant changes in our brain by changing how we think</p>
                <p>It's important to tune people out, just focus on yourself and do better</p>

            <h2>Renaissance Learning and Unlocking Your Potential 2</h2>
                <h2>Teamwork</h2>
                    <p>The right hemisphere of the brain helps us step back and put our work into focus of a bigger picture. <br>
                        The right side of the brain is important for getting into the right track and doing reality checks 
                    </p>
                    <p>The left hemisphere of the brain is far too focused, it provides a analytical and upbeat approach, but also rigidity, dogmatism, and egocentricity or overconfident personalities.</p>
                    <p>The best way to catch your blind spots and errors is to brainstorm and work with others working on the same topic.</p>
                    <p>Teamwork with others opens up a larger diffused mode thinking of discussions. Catch what you miss and cannot see within your own perspective <br>
                        Explaining to others, can also build your own understanding.
                    </p>
                <h2>A Test Checklist</h2>
                    <p>Testing helps concentrate the mind far better than just learning. </p>
                    <ul>A Checklist
                        <li>Did you make a serious effort to understand the text?</li>
                        <li>Did you work with classmates on homework problems?</li>
                        <li>Did you attempt to outline every problem solution</li>
                        <li>Did you participate actively in group discussions</li>
                        <li>Did you consult with instructor</li>
                        <li>Did you understand all your homework problems when they were handed in?</li>
                        <li>Did you ask in class for explanations of homework problem solutions that werent clear to you</li>
                        <li>If you had a study guide, did you carefully go through it before the test and convince yourself you could do everything on it?</li>
                        <li>Did you go over the study guide and problems with classmates and quiz one another?</li>
                        <li>If there was a review session before the test, did you attend and ask questions about anything you werent sure about?</li>
                        <li>Did you get a good night's sleep</li>
                    </ul>
                <h2>The Hard Start-Jump to Easy Technique</h2>
                    <p>Tough problems should actually be started first, since they take a lot of time. They also use a lot of diffuse mode thinking</p>
                    <p>However the best way is to start with a hard problem and immediately jump to the easy ones. <br>
                        Starting hard loads the first most difficult problem in mind and then switches attention away from it. These activities will activate the diffused mode thinking.
                        Complete the easy problem as much as you can, and move back to a difficult problem, to solve some steps that may be easier for you now, now that youve done some easy problems with the similar concept. Then move back to the easy problems again.
                    </p>
                    <p>This technique saves time and can be compared to a chef, multitasking by letting a steak cook while slicing tomatoes at the same time. <br>
                        The technique makes more efficient use of your brain by allowing different parts of the brain to work simultaneously on different thoughts. <br>
                        It guarantees that you will have a little work done on every problem, because you are switching back and forth to another and it prevents einstellung.
                    </p>
                    <p>Give your brain a chance to reflect on harder challenges</p>
                
                <h2>Final Helpful Hints for Tests</h2>
                    <p>If you shift your thinking when you face fear, panic, it can change your outlook of the situation.</p>
                    <p>You can deep breathing technique, where you place your hand on your stomach and draw a deep breath <br>
                        effectively counteracting the fight or flight responses, that fuels anxiety. You can practice this to make the action easier. 
                    </p>
                    <p>Try consciously relaxing your tongue </p>
                    <p>Always have a plan B for the alternative career just in case things dont work out. This reduces stress, and the best you can do is move forward</p>
                    <p>Blink, shift your attention, check your answer from different perspectives</p>

                
        </fieldset>
        <fieldset id="class-02"> 
            <legend>Class 02 - HTML</legend>
            <p>Software Engineer- someone who can write code, and knows the tools and systems behind the code, including the math and efficiency</p>
        
            <ul id="html-tags"> Tags:
                <li><code>br</code> - break a line of text, make a new line</li>
                <li><code>hr</code> - horizontal rule, a thematic break to separate content, makes a line</li>
                <li><code>ul/ol/li</code> - unordered/ordered lists/list items</li>
                <li><code>h1-h6</code> - heading tags based on importance </li>
                <li><code>p</code> - paragraph</li>
                <li><code>span</code> - short text</li>
                <li><code>pre</code> - preserve whitespace</li>
                <li><code>img ... src</code> - images, </li>
                <li><code>a ... href</code> - links</li>

                <hr id="Assisted Device Elements">
                <li><code>em</code> - emphasis</li>
                <li><code>strong</code> - important</li>

                <hr id="containing-elements">
                <li><code>div</code> - empty container</li>
                <li><code>section</code> - define a section, thematic grouping, typically used with a heading</li>
                <li><code>article</code> - independent, self-contained content for sharing and reusablity; forum/blog posts, user comments, product cards, newspaper articles</li>
                <li><code>aside</code> - ancillary or extra content (ads, sidebar); represents a portion of a document whose content is only indirectly related to the document's main content. Asides are frequently presented as sidebars or call-out boxes.</li>
                <li><code>header</code> - container for introductory content or a set of navigational links for document or section</li>
                <li><code>footer</code> - define a footer for a document or section; authorship, copyright, contact, sitemap, back to top</li>
                <li><code>figure</code> = specify self-contained content like illustrations, diagrams, photos, code listings <br>
                    <li><code>figcaption</code> = define a caption for a figure element; can be placed 1st or last child of the figure element</li>
                </li>
            </ul>

            <p>Replit or Glitch are great code editors that are free and online</p>
        </fieldset>
        <fieldset id="class-03">
            <legend>Class 03 - More HTML</legend>
            <p>CDN - content delivery network (images are heavy, in that it takes a while to download, but not with CDN), <br>
                CDNs places the image and puts it in servers around the world that are closer to you, so you dont have to wait that long for an image to load or other heavier files</p>
            <ul id="html-tags">
                <hr id="html-structure">
                <li><code><!DOCTYPE html></code> - define this document type is html</li>
                <li><code>html</code> - root tag,everything html goes inside here</li>
                <li><code>head</code> = contains metadata about the webpage, including information such as the webpageâ€™s title, scripts, and stylesheets. <br>
                    The head element is not visible to the user and is used to provide information to the browser and search engines about the webpage. <br>
                    everything the browser needs <br>
                    <pre>
                        <head>
                            <title>My Website</title>
                            <link rel="stylesheet" href="styles.css">
                            <script src="script.js"></script>
                            <style></style>
                            </head>
                    </pre>
                    
                </li>
                <li><code>body</code> = contains all the contents of an HTML document, everything the user needs</li>
                <hr>
                <li><code>nav</code> affects SEO by ignoring these repeated link names showing up, defines a set of navigational links, usually for major blocks of links (goes inside header)</li>
                <ul><code>form</code> - make a form element for your inputs
                    <li><code>action</code> = indicates where the form data should be sent ex:<code><form action="/submit-url"></form></code> is sent to the path of /submit-url</li>
                    <li><code>method</code> = The method attribute specifies how to send form-data to the URL specified in the action attribute. 
                        The form-data can be sent via a GET request as URL parameters (with method="get") or via a POST request as data in the request body (with method="post").
                    </li>
                    <ul><code>label</code> - a label to accompany your input, you can place text here before your input
                        <li><code>for</code> - an attribute for linking to your input's id attribute (you can prove its connected, when you click on the label text because it will focus on the input and indicate user input</li>
                    </ul>
                    <ul><code>input</code> => input element for adding different types of input
                        <li><code>type</code> - specify what type of input this is. Some types have built in checks and changes the way your input functions</li>
                        <li><code>id</code> - links to your label element's for attribute</li>
                    </ul>
                </ul>
            </ul>

            <ul>Progressive Enhancement
                <li>content - core of our website, html</li>
                <li>presentation - css</li>
                <li>client-side scripting - wrap our presentation and content, javascript</li>

                <p>Everything you add more and more things to your webpage, it makes it more heavy and it will increase the page load speed</p>
            </ul>

        </fieldset>
        <fieldset id="class-04">
            <legend>Class 04 - CSS</legend>
            <p>CSS can go inline (style attribute), in the head (style tag in head tag), in a separate file (css files)</p>
            <p>The only time you should be using inline styles in the professional world is emails, </p>
            <p>The only time you would use style in the head is with amazon, they have stated for every one second their page load increases they lose 1 million dollars a day. <br>
                Instead they use critical path css, which describes the essential css needed to load above the fold. <br>
                Loading above the fold means all the content you see before you start scrolling <br>
                Amazon will place that lil bit of css, enough to load above the fold, onto the head element. And the rest of the css, will be loaded in a separate css file</p>
        
            <p>To use a separate css file : use link with file path ==> from this html file, i want to go into this folder and then i want you to find this css file {folder/style.css}</p>

            <hr id="reading-css">
            <p>CSS Syntax - selectors, (property, property values) - declaration</p>
            <pre>
                The whole thing is called a rule.
                The p itself is called a selector.
                It is followed by a set of declarations in declaration block (the curly braces). 
                p{
                    color: red;
                    font-weight: bold;
                }
            </pre>
            <p>Since CSS(Cascading style sheets) is read from top to bottom, codes below can override what came before, also known as a Cascade</p>
        
            <hr id="css">
            <ul>
                <ul><code>color</code> - a css property to display a color to the element
                    <h3>RGB Color Model <code>rgb</code></h3>
                    <p>3 parameters representing red, green, and blue value. They range from 0 to 255. Half range (127) gets tierary colors. <br>
                    And combining any combo of the 3 colors gets you secondary colors, with the range varying the color shades.</p>
                    
                    <hr>
                    <h3>Hex Colors</h3>
                    <p>Hex color values start with a # character and take six characters from 0-9 and A-F (in that order). 
                        The first pair of characters represent red, the second pair represent green, 
                        and the third pair represent blue. For example, #4B5320. (there is an extra pair for alpha channel)
                    </p>
                    <p>00 is 0% of that color, and FF is 100%</p>

                    <hr>
                    <h3>HSL Color Model (Hue Saturation Lightness) <code>hsl</code></h3>
                    <p>The CSS hsl function accepts 3 values: a number from 0 to 360 for hue, a percentage from 0 to 100 for saturation, and 
                        a percentage from 0 to 100 for lightness.</p>
                    <p>If you imagine a color wheel, the hue red is at 0 degrees, green is at 120 degrees, and blue is at 240 degrees.</p>
                    <img src="http://thenewcode.com/assets/images/hsl-color-wheel.png" alt="color wheel">
                    <p>Saturation is the intensity of a color from 0%, or gray, to 100% for pure color.</p>
                    <p>Lightness is how bright a color appears, from 0%, or complete black, to 100%, complete white, with 50% being neutral.</p>
                    <ul>
                        <li><code>rgba</code> -  rgb with an alpha channel parameter (alpha must be decimal system 0 - 1.0)</li>
                        <li><code>hsla</code> - hsl with an alpha channel parameter</li>
                    </ul>
                </ul>
                <li><code>font-family</code> - set a font for the element. They can be linked to your html at head element with href and rel <br>
                    The font linking needs to come before our css link, because the css will most likely use the font (because of css reading from top to bottom) <br>
                    You can have fallbacks in your font-family, which are separated by commas, and finally your default fonts. 
                </li>
                <ul><code>font-weight</code> -  how thick the font is, these can be numbers or keywords
                    <li><code>lighter|normal|bold|bolder|100...900 </code></li>
                </ul> 
            </ul>

            <hr id="css-selectors">
            <li><code>#idname{}</code> - target id attributes in css with # (meant to be unique)</li>
            <li><code>.classname{}</code> - target class attributes in css with . (meant to be multiple)</li>
            <li><code>parent > child</code> -select an element that is the direct descendent of another element </li>
            <p>Specificity - the weight of some selectors take priority over others with less weight or points (regardless of cascade) <br>
                Important and inline styles are worth the most in points (think 1000) <br>
                IDs are (100) classes are (10) and tags are (1) <br>
                The cascade can help us from repeating code. 
            </p>
        </fieldset>
        <fieldset id="class-05">
            <legend>Class 05 - CSS layout</legend>
            <hr id="css-selecting-by-relationship">
                <li><code>parent > child {}</code> - select all child elements immediately inside the parent element (direct descendant)</li>
                <li><code>parent child {}</code> - select all child elements inside the parent element (any level deep)</li>
                <li><code>previous sibling + next sibling {}</code> - select the next sibling that has the previous sibling immediately coming after it</li>
            
            <hr id="box-model">
                <li><code>margins border - padding</code></li>

            <hr id="floats">
                <p>Floats fight as hard as they can to get into a corner (whether left or right)</p>
                <p>floats can be used to float containers next to each other with percentages(divide evenly with 4 decimals places to fit)</p>
                <p>Remember that floated object break out of the structure (as they float up), to solve this. Tell other elements to use <code>clear:both</code> to check if theres anything floating and will fit itself as if the floaters are actually there in structure</p>
                <p>The <code>clear</code> CSS property sets whether an element must be moved below (cleared) floating elements that precede it. The clear property applies to floating and non-floating elements.</p>
                <a href="https://stackoverflow.com/questions/4224476/floatright-reverses-order-of-spans">Handle right floats</a>
            
            <hr id="external css styles & hacks">
                <p>reset.css = resets everything on your styles</p>
                <p>normalize.css = default styling we're used to</p>
                <p>Box Model Hack - makes all box model sizing fit the border-box boundaries (box-sizing: border-box;)</p>
                <p>Clear Fix Hack - clears floats to ensure the element contains all its child elements and prevents the parent element from collapsing <br>
                    <code>
                        .clearfix:after{
                            content: ".";
                            display: block;
                            clear: both;
                            visibility: hidden;
                            line-height: 0;
                            height: 0;
                        }
                    </code>
                </p>
        </fieldset>
        <fieldset id="class-07">
            <legend>Class 07 - Responsive Websites</legend>
            <ul>What Makes a site Responsive?:
                <li>Fluidity - everything is a percentages, responding to your window size</li>
                <ul>Elasticity - using fonts and text to em & rem units (responsive unit of measure)
                    <li><code>em</code> - font size of the closest parent multiplied by number of ems</li>
                    <li><code>rem(root em)</code> - font size from the root (html element)</li>
                    <li>the default font size for most browsers is 16px. We can make the font size equal to 62.5% of 16px to get 10px</li>
                </ul>
                <ul>Content Decisions - decisions you make to show what content in different resolutions and screen sizes:
                    <img src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2020/09/media-query-anatomy.jpg?resize=1000%2C66&ssl=1">
                    <pre>
                        @media not|only mediatype and (mediafeature and|or|not mediafeature) {
                            CSS-Code;
                        }
                    </pre>
                    <ul style="list-style-type: none">
                        <li>keywords
                            <ul>
                                <li><code>not</code> - The not keyword inverts the meaning of an entire media query.</li>
                                <li><code>only </code> - only: The only keyword prevents older browsers that do not support media queries with media features from applying the specified styles. It has no effect on modern browsers.</li>
                                <li><code>and</code> - and: The and keyword combines a media feature with a media type or other media features.</li>
                            </ul>
                        </li>
                        <li>Media Type
                            <ul>
                                <li><code>all</code> - matches all devices of media</li>
                                <li><code>print</code> - matches documents view in print preview or any media for content that is intended to print</li>
                                <li><code>screen</code> - matches devices with a screen (it also means 0)</li>
                                <li><code>speech</code> - matches devices that read content audibly, like screenreaders</li>
                            </ul>
                        </li>
                        <li>Media Features
                            <ul>
                                <li><code>max-width|min-width</code> - apply css queries based on the viewport width
                                    <pre>
                                        @media(max-width: 960px){
                                            .card{
                                                padding: 2rem;
                                            }
                                        }
                                    </pre>
                                </li>
                            </ul>
                        </li>
                        <br>
                        <h3>Keywords</h3>
                        <li><code>not</code> - keyword inverts the meaning of the entire media query</li>
                        <li><code>only</code> - keyword prevents older browsers that do not support media queries; hide style sheets from older browsers </li>
                        <li><code>and|or</code> - keyword for combining/choosing media features</li>
                    </ul>
                </ul>
            </ul>

            <hr id="meta-tag-for-media">
            <li><code><meta name = "viewport" content="width=device-width, intial-scale=1.0"></code> <br>
                This basically tells the browser to make our media queries work on all devices, without it, mobile devices can't process our media queries. <br>
                It figures out the width of this screen regardless of device, and sets it to the width. The initial-scale is the zoom level <br>
                You can also set <code>user-scalable = "no"</code> but this is not great for accessibility since, it stops people from zooming with fingers. 
            </li>
        </fieldset>
        <fieldset id="class-08">
            <legend>Class 08 More CSS</legend>
            <p>1mb.club - all websites that keep their code light and not heavy, accessible to people who dont have high speed broadband or good internet</p>
        </fieldset>
        <fieldset id="class-11">
            <legend>CSS Layout & Flexbox</legend>
            <p>All additional details are placed on flexbox on my studyguide already</p>
            <li><code>previous sibling ~ general sibling</code> - selects all general sibling that are a sibling of the previous sibling</li>
        </fieldset>
        <fieldset id="class-12">
            <legend>Javascript</legend>
            <li>What is programming? - the task of writing those instructions in a language that the computer can understand</li>
        
            <li>Simple Circuit - when the switch is open, the led is off. When the switch is closed the light is on. (this is because when the switch is closed, it completes the circuit allows electricity through)</li>
            <p>We can represent the switch open(up) and close(down) with 0s and 1s</p>
            <p>With 2 switches, we can introduce logic when its 11, representing if switch 1 and switch 2 are closed, led is on</p>
            <ul class="js-code">
                <ul>JS Syntax:
                    <li>Semicolon, Brackets, Parentheses, Quotations, Ternary Operators, etc.</li>
                </ul>
                <p>Javascript rerenders the file/DOM itself, not the files you have for html and css</p>
                <p>The DOM(document object model) is a rerendering of the html and rerenders to its default when refreshed (recipes: html css), and represents a tree of nodes we can manipulate with javascript</p>
                
                <hr id="js-variables">
                <p>Variables tell our program to remember values for us to use later on and it stores a value.
                </p>
                <p>Declaration - declare a variable and it takes up space in the memory. You can then recall the variable at a later time</p>
                <p>Assignment - assign/store a value to the variable</p>
                <ul>Naming Conventions:
                    <li>camelCase - start with a lowercase, then every word after that start with uppercase</li>
                </ul>

                <hr id="js-data-types">
                <ul>Data Types:
                    <li>Strings - stores text, surrounded by quotes</li>
                    <li>Numbers - numerical (int, float(decimals)) signed (int: +4, float: -10.943)</li>
                </ul>

                <hr id="operators">
                <ul>Operators:
                    <li><code>Arithmetic: + - * / %</code></li>
                    <li><code>Logical: == === != !== > &lt; >= &lt;=</code></li>
                    <p>Know the difference between assigning and comparison = / ==</p>
                </ul>

                <ul class="escape-characters">
                    <p>Warning, these fall closely with css, and should be organized into that language instead, so we usually dont use this</p>
                    <li><code>\n</code> - newline</li>
                    <li><code>\t</code> - tab</li>
                </ul>
                <li><code>onclick = {myfunction}</code> - event that reads clicking events and passes the function</li>

                <ul class="js-class-projects">
                    <ul id="color-picker">
                        <li><code>document.getElementById('purple').onclick= partyPurple</code> - this sets an onclick event to a function to run when click.</li>
                    </ul>
                    <ul id="simple-calculator">
                        <ul><code>.addEventListener('{event}',{function you want to run when the event happens})</code> - add an event with a function that triggers when you activate it <br>
                            <li><code>click</code> - an event for clicking something</li>
                            <li><code>mouseover</code> - an event for hover</li>
                            <li><code>mouseout</code> - an event when exiting a hover </li>
                            <li><code>submit</code> - an event for form elements</li>
                        </ul>
                        <code style="white-space: pre-wrap; display: block;">
                            &lt;!DOCTYPE html&gt;
                            &lt;html lang=&quot;en&quot;&gt;
                                &lt;head&gt;
                                    &lt;meta charset=&quot;utf-8&quot;&gt;
                                    &lt;meta name=&quot;description&quot; content=&quot;Not so great calculator&quot;&gt;
                                    &lt;meta name=&quot;keywords&quot; content=&quot;calculator, bad, numbers&quot;&gt;
                                    &lt;title&gt;Not So Great Calculator&lt;/title&gt;
                                    &lt;!-- external CSS link --&gt;
                                    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot;&gt;
                                    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;
                                &lt;/head&gt;
                                &lt;body&gt;
                                    &lt;h1&gt;Not So Great Calculator&lt;/h1&gt;
                                    &lt;ul&gt;
                                        &lt;li id=&quot;pumpkin&quot;&gt;0&lt;/li&gt;
                                        &lt;li id=&quot;dominosPizza&quot;&gt;+3&lt;/li&gt;
                                        &lt;li id=&quot;zebra&quot;&gt;+9&lt;/li&gt;
                                        &lt;li id=&quot;cantThinkOfAnything&quot;&gt;-2&lt;/li&gt;
                                    &lt;/ul&gt;
                                    &lt;h2&gt;Result: &lt;span id=&quot;placeToPutResult&quot;&gt;&lt;/span&gt;&lt;/h2&gt;
                                    &lt;script type=&quot;text/javascript&quot; src=&quot;js/main.js&quot;&gt;&lt;/script&gt;
                                &lt;/body&gt;
                            &lt;/html&gt;

                            let total = 0;

                            document.querySelector('#pumpkin').addEventListener('click', makeZero);
                            document.querySelector('#dominosPizza').addEventListener('click', jumanji);
                            document.querySelector('#zebra').addEventListener('click', add9);
                            document.querySelector('#cantThinkOfAnything').addEventListener('click', sub2);

                            function makeZero() {
                                total = 0;
                                document.querySelector('#placeToPutResult').innerText = total;
                            }

                            function jumanji() {
                                total = total + 3;
                                document.querySelector('#placeToPutResult').innerText = total;
                            }

                            function add9() {
                                total = total + 9;
                                document.querySelector('#placeToPutResult').innerHTML = total;
                            }

                            function sub2() {
                                total = total - 2;
                                document.querySelector('#placeToPutResult').innerHTML = total;
                            }
                        </code>
                    </ul>
                    <ul id="day-of-the-week">
                        <code style="white-space: pre-wrap; display: block;">
                        &lt;!DOCTYPE html&gt;
                        &lt;html lang=&quot;en&quot;&gt;
                            &lt;head&gt;
                                &lt;meta charset=&quot;utf-8&quot;&gt;
                                &lt;meta name=&quot;description&quot; content=&quot;This app lets you know today is class, the weekend, or a boring day&quot;&gt;
                                &lt;meta name=&quot;keywords&quot; content=&quot;class, weekend, boring&quot;&gt;
                                &lt;title&gt;What is today?&lt;/title&gt;
                                &lt;!-- external CSS link --&gt;
                                &lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot;&gt;
                                &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;
                            &lt;/head&gt;
                            &lt;body&gt;
                                &lt;h1&gt;What is today?&lt;/h1&gt;
                                &lt;form&gt;
                                    &lt;label for=&quot;day&quot;&gt; Day of the week: &lt;/label&gt;
                                    &lt;input id=&quot;day&quot; type=&quot;text&quot; placeholder=&quot;Day of the week&quot;&gt;
                                &lt;/form&gt;
                                &lt;button id=&quot;check&quot; type=&quot;button&quot; name=&quot;button&quot;&gt;check&lt;/button&gt;
                                &lt;h2 id=&quot;placeToSee&quot;&gt;&lt;/h2&gt;
                                &lt;script type=&quot;text/javascript&quot; src=&quot;js/main.js&quot;&gt;&lt;/script&gt;
                            &lt;/body&gt;
                        &lt;/html&gt;

                        /******************************************
                        /* HOT GARBAGE - PLEASE DON'T MIMIC THIS CSS
                        /*******************************************/

                        /* Box Model Hack */
                        *{
                            box-sizing: border-box;
                        }

                        /******************************************
                        /* LAYOUT
                        /*******************************************/
                        h1, h2, form{
                        text-align: center;
                        }
                        button{
                        display: block;
                        margin: 20px auto;
                        }
                        ul{
                        width: 100px;
                        height: 200px;
                        border: 3px solid black;
                        margin: 0 auto;
                        list-style: none;
                        padding: 0;
                        }
                        li{
                        text-align: center;
                        width: 94px;
                        height: 49px;
                        border: 1px solid black;
                        }
                        h2{
                        font-size: 100px;
                        color: red;
                        font-weight: bold;
                        }
                        /******************************************
                        /* ADDITIONAL STYLES
                        /*******************************************/
                        
                        //JSSSSS
                        document.querySelector('#check').addEventListener('click', check)
    
                        function check() {
    
                        const day = document.querySelector('#day').value
    
                        //Conditionals go here
                        }
                    </code>
                    </ul>
                </ul>

                <ul class="js-function-expressions">
                    <li>Function Declaration - a way of creating a function with the following syntax: <br>
                        <code>function funcName(){}</code>
                    </li>
                    <li>Function Expression - another way to write function by creating a variable and placing a function inside it: <br>
                        <code>let variable = function(){}</code>
                    </li>
                    <p>No matter how its created the function is a value at the end of the day. When we place that value inside a function of itself, it will run regardless of the parenthesis</p>
                    <p>Assigning a variable to a variable with a function will copy the function that the variable has over to the other</p>
                    <p>A semicolon is only necessary in function expression because its not from the function but from the variable statement itself as part of the normal syntax.</p>
                    <p>A key difference is that a function declaration can be called earlier than it is defined and it is restricted within its own scope, <br>
                        but function expression is fully created when the execution reaches its right side so earlier code calling the function doesnt do anything though it isn't restricted by scope.
                    </p>
                    
                    <li>Ternary Operators => conditional ? {true} : {false} which we can use to assign a function expression if theres a choice to</li>
                    <li>Callback Functions - A callback is a function passed as an argument to another function</li>
                </ul>
                <ul class="js-arrow-functions">
                    <code>let func = (arg1, arg2, ..., argN) => expression;</code>
                    <p>if there are no arguments there still must be a parenthesis for the syntax of arrow functions</p>
                    <pre>
                        let age = prompt("What is your age?", 18);

                        let welcome = (age &lt; 18) ?
                        () => alert('Hello!') :
                        () => alert("Greetings!");

                        welcome();
                    </pre>
                
                </ul>
                
            </ul>
        </fieldset>
        
        <fieldset id="class-13">
            <legend>Class 13 - More Javascript Examples</legend>
            <p>Program - a set of instructions that you write to tell a computer what to do</p>
            <p>Programming - the task of writing instructions in a language that a computer can understand</p>

            <li><code>`${var}`</code> - template literals - allows variables in a string format using ticks</li>
            <ul class="js-class-projects">
                <p>The angry parent sim and bachelor is on my replit</p>
            </ul>
        </fieldset>
        <fieldset id="class-14">
            <p>Remember that statements execute from left to right, so incrementing positions on left or right can change how the variable outputs</p>
            <p>Functions - a method with sets of instructions that executes when called upon, they are the building blocks of a program <br>
                They can be declared(putting into memory) and assigned through parameters(place something in that bucket of memory), then called with the function and parenthesis
                
                <pre>
                    //function declaration
                    function name(parameters){
                        //body
                    }
                    //function call
                    name(arguments) //We are passing in arguments into the function. Which is received as a parameter, which is local to the function only. 
                </pre>
            
            </p>
        </fieldset>
        <fieldset id="class-15">
            <legend>Freelancing</legend>

            <ul>Templates -help us design a website quicker 
                <a href="https://html5up.net">Free & not shady</a>
                <a href="https://themeforest.net/"></a>
                <a href="https://wrapbootstrap.com/"></a>
            </ul>
            <ul>Hosting- hosting a website
                <a href="netlify.com/drop"></a>
                <p>If your client wants their personal domain, they can go for namecheap and IWantMyName for cheaper rates</p>
                <p>Tips for placing 100 Dev on resume, say it is an agency with a 100dev's academy training program</p>
            </ul>
            <ul>Proposals that you can send to clients to describe what you will provide of your services (what you will do and what you will send)
                Proposify & Panda Doc are both free...
                namecheap has a free logo maker
            </ul>
            <ul>Contracts - make contracts with your clients
                Contract Killer is Free

                Contract Requirements: 
                <pre>
                    (indefinition clause - not definite or uncertain)
                    We can't guarantee that our work will be error-free and so we can't be liable to you or any third-party for damages,
                    including lost profits, lost savings or other incidental, consequential or special damages, even if you've advised us of them.

                    We'll own any intellectual property rights we've developed prior to, or developed separately from this project and not paid for by you.
                    We'll own the unique combination of these elements that constitutes a complete design and we'll license its use to you
                    (ONCE PAID IN FULL), exclusively and in perpetuity for this project only, unless we agree otherwise. 
                    (I own all the code i wrote, i am merely giving you a unique license for you to use the work.)
                </pre>
            </ul>
            <p>Closing - ask what would they like their project to be then ask whats your ballpark budget, or estimated budget</p>
            <p>Always leave room to get help, tell your client the deadline is double of what you think will take you so in case something goes wrong you have time to fix it</p>
            <p>Password Manager - Lastpass Bitwarden Onepass</p>
        </fieldset>
        <fieldset id="class-16">
            <legend>Javascript Loops</legend>
            <p>Functions are simple sets of instructions, reusable, perform one action as a best practice, and form the basic building blocks of a program</p>
        </fieldset>
        <fieldset id="class-19">
            <legend>Javascript Arrays</legend>
            <li><code>forEach(function(currentValue, index, arr), thisValue(value passed to "this" on arr) )</code> => similar to map() but this method:
                <ul>
                    <li>mutates the original array and loops through the elements</li>
                    <li>the function itself will always return undefined</li>
                    <li>is unable to chain to other methods, because its undefined</li>
                </ul> 
            </li>
        </fieldset>
        <fieldset id="class-21">
            <legend>Class 21</legend>
            <p>You can make object with functions by setting them outside of the object or inside with object- key value syntax</p>
            <p>Remember if you dont have a return statement on your function it comes out as undefined</p>
        </fieldset>
        <fieldset id="class-22">
            <legend>Class 22 - Javascript Objects</legend>
            <p>Objects are a collection of variables(w/values) and functions</p>
            <p>Objects represent the attributes(variables) and behavior(methods) of something used in a program</p>
            <p>Object variables are called properties and object functions are called methods</p>
            <p>Object stores 'keyed' collections</p>

            <p>If we want to build multiples of the same object we can use constructors and prototypal inheritance</p>
            <p>We can use naming convention like uppercase on first word to indicate a function is a constructor:
                <pre>
                    function MakeCar(carMake, carModel, carColor, numOfDoors){
                        this.make = carMake
                        this.model = carModel
                        this.color carColor
                        this.doors = numOfDoors
                        this.honk = function(){
                            alert('BEEP BEEP FUCKER')
                        }
                        this.lock = function(){
                            alert(`Locked ${this.doors} doors!`)
                        }
                    }
                </pre>
            </p>
            <p>We can use the new keyword to make a new instance of an object.</p>
            <p>A prototype is another object that is used as a fallback source of properties <br>
                Meaning adding prototype properties adds directly to the template of an object (which do not show directly inside a constructor function, but internally instead)
            </p>
            <p>You actually save memory, by using prototypes, because its placed only on the constructor function itself, which through inheritance allows all instances of that function to share the same data, <br>
                compared to this.method() which would make many of the same methods, taking us memory. 
            </p>
            <p>A constructor's prototype provides a way to share methods and values among instances via the instance's private [[Prototype]] property.</p>
            <p>Prototypical inheritance or the general sense of inheritance chain is when an instance of an object checks itself to see if it has a property or method <br>
                If not, it can check the factory/template/constructor Object that made it and it can keep going up until the object global prototype. 
            </p>

            <p>Classes introduced from ES6 are just tactical sugar on top of constructors</p>

            <pre>
                function MakeSFCharacter(punch, kick, catchPhrase, specialMove){
                    this.punch = punch
                    this.kick = kick
                    this.catchPhrase = catchPhrase
                    this.specialMove = specialMove

                    this.taunt = () => console.log(`You can't handle my ${this.specialMove}`)
                    this.winning = () => console.log(`Haha! ${this.catchPhrase}`)
                    this.dash = () => console.log('Whoopp, missed me!')

                }

                let ryu = new MakeSFCharacter('high', 'high', 'Get OVER HERE', 'HADDDOOOOKKKEEENNNNN')
            </pre>

            <ul id="Object-Oriented Programming with Mosh">
                <li>Procedural Programming - program with a set of functions and variables. <br>
                    This is not ideal as changing functions can break others, leading to spaghetti code. <br>
                    Objects offer a way to group these properties(variables) and methods(functions) that operate on them into a single object.
                </li>
                <p>4 Pillars of Object-Oriented Programming - Encapsulation, Abstraction, Inheritance, and Polymorphism</p>
                <ul>
                    <li>Encapsulation - group related variables and functions that operate on them into objects and therefore reduce complexity and increase reusability. <br>
                    
                    Procedural has a lot more parameters for its functions, but OOP does not because it can directly grab the properties of the object so the function parameters can stay empty. 
                    With lower parameters, you can easily use and maintain the code. <br>
                    "The best functions are those with no parameters!" - Uncle Bob - Robert C Martin
                    </li>
                    <li>Abstraction - Hide the details and complexity and only show the essentials, Allows us to have a simpler interface and reduce impact of change (bugs) by grouping our functions together on our objects</li>
                    <li>Inheritance - eliminates redundant code, like making an instance of an object template ex: TextBox and Checkboxes inherit from HTMLElement object, which reduces the amount of code we need to write otherwise.</li>
                    <li>Polymorphism - many forms; through procedural programming we would have so many if else or switch/case statements, but with objects we can simplify the process</li>
                </ul>
                
            
                <li><code>{}</code> - object literal syntax</li>
                <li>Behavior - when an object has one or more methods</li>
                
                <p>When an object has a behavior, we should be using a factory/constructor function: <br>
                    <li>Factory - does not have a constructor, must return an object, simply create an instance without new keyword
                        <pre>
                            function createCircle(radius){
                                return{
                                    radius, //radius: radius
                                    draw: function(){
                                        console.log('draw')
                                    }
                                }
                            }
                        </pre>
                    </li>
                    <li>Constructor - uses this keyword, create an instance with new keyword, <br>
                        .constructor => references the function used to create an object<br>
                        The new keyword is important, because it creates an empty object, where it points to the this keyword. <br>
                        Without it, it would point to the window object and therefore assign global properties and variables and be affected by everything and create bugs.
                        We don't need to 'return this' statement as this is done by the new keyword. 

                        <pre>
                            function Circle(radius){
                                this.radius = radius;
                                this.draw = function(){
                                    console.log('draw');
                                }
                            }

                            WHAT IS HAPPENING INTERNALLY? 
                            Circle.call({}, # of arguments added explicitly) is the same as new Circle()
                            //this keyword references the empty object and passes arguments, (this is done in the background with new Circle(1))
                            Circle.apply({}, [1,2,3]) 
                            //allows you to pass an array as an argument to a function basically 

                            const another = new Circle(1);

                            WHAT IS HAPPENING INTERNALLY?
                            The 'new' keyword is used to create an empty object.
                            Then it sets 'this' to point to the object itself.
                            Return the object from the function directly. (so you don't need a return keyword)

                            Without the new keyword we define 'this' to the global object, which on the browser is window.
                        </pre>
                        <pre>
                            When you set an object with a variable internally this happens:
                            let x = {} means =>
                            let x = new Object{} //object itself here is a constructor function

                            same with other things:

                            new String(); //'', "", `` (string literals is easier than using a constructor)
                            new Boolean(); // true, false (boolean literals)
                            new Number(); // 1, 2, 3

                            BASICALLY EVERY OBJECT HAS A CONSTRUCTOR PROPERTY!!! The constructor references the function used to create the object itself. Using .constructor will give you the original function. 

                            even functions itself:

                            function Circle(radius){
                                this.radius = radius;
                                this.draw = function(){
                                    console.log('draw');
                                }
                            }
                            =>
                            const Circle = new Function('radius',
                            `   this.radius = radius;
                                this.draw = function(){
                                    console.log('draw');
                                }
                            `);
                            //if we create an instance from this 'new function' syntax, with the new keyword it would be the same thing. THIS MEANS FUNCTIONS ARE ALSO OBJECTS.
                        </pre>
                    </li>
                </p>

                <hr>

                <li>Value(Primitive) Types: Number, String, Boolean, Symbol, undefined, null</li>
                <li>Reference Types: Object, Functions, Arrays</li>
                <p>Primitives are copied/passed by their values, Objects are copied/passed by their reference in memory</p>
            
                <p>Objects are dynamic, meaning we have the option to add or remove properties to them through dot or bracket notation</p>
                <p>We generally use bracket notation when a property name is assigned somewhere else to a variable perhaps or the naming-convention does not work on dot notation</p>
                <li><code>delete {targetproperty}</code> - delete properties from objects</li>

                <hr>

                <li>Iterate over object properties: for(let x in {object}){}</li>
                <li><code>'{property}' in {object}</code> - checks to see if a property is in an object</li>
                <li><code>Object.keys({object})</code> - returns all the object's keys</li>

                <hr>

                <p>Abstraction - hide details, show only essentials</p>
                <p>You dont want all your objects implementation to be public, as any chance will require other changes in your code. <br>
                    But place inside a template function, and you only need to change one thing</p>
                <p>To show abstraction in object, you can make functions call other functions inside through Private properties and methods</p>

                <p>Private methods and properties: <br>
                    Can be made through assigning local variables instead of implementation detail as a this.property. <br> 
                    Thanks to closure, inner functions have access to outer function variables to use still because they stay in memory, which is different from scope which die when variables go out of scope. <br>
                    So when you check your members(properties and methods) of an object only 'this' properties and methods show up.
                    
                    <pre>
                        function Circle(radius){
                            this.radius = radius;

                            let defaultLocation = {x:0, y:0}; 
                            let computeOptimumLocation = function(factor){
                            //private because its a local variable. These are part of the closure of the draw function.
                            }

                            this.draw = function(){
                                computeOptimumLocation(0.1);
                                //defaultLocation
                                //this.radius
                                console.log('draw');
                            }
                        }
                    </pre>

                    <p>What if you want to simply want to call a private property or method though through dot or bracket notation? : <br>
                        Then you get use a get/set functions instead like <code>this.getDefaultLocation</code>, but you would have to type the appropriate keyword as well. <br>
                        You can then use: <br>
                        <li><code>Object.defineProperty(this, '{property}', 
                            { 
                                get: function(){return {property}} //getter functions read property, it is read-only
                                set: function(value){ {property} = value} //setter functions set property
                                //both of these are unique keywords for javascript
                            }
                        )
                        </code></li>
                        <pre>
                            Object.defineProperty(this, 'defaultLocation', {
                                get: function() { return defaultLocation}; 
                                set: function(value) { 
                                    if(!value.x || !value.y) 
                                        throw new Error('Invalid location.');
                                    
                                        defaultLocation = value;
                                }
                            });

                        </pre>
                        <pre>
                            function Stopwatch(){
                                let startTime, endTime, running, duration = 0;
                                this.start = () => {
                                    if(running)
                                        throw new Error('Stopwatch has already started.');
                                    
                                    running = true;
                                    startTime = new Date(); //start timer
                                }
                            
                                this.stop = () => {
                                    if(!running)
                                        throw new Error('Stopwatch is not started.');
                                    
                                    running = false;
                                    endTime = new Date(); //end timer (Date is from the global object)

                                    const seconds = (endTime.getTime() - startTime.getTime()) / 1000;
                                    duration += seconds;
                                }

                                this.reset = function(){
                                    startTime, endTime, running, duration = 0;
                                }

                                Object.defineProperty(this, 'duration', {
                                    get: function() {return duration;}
                                })
                            }

                        </pre>
                    </p>
                </p>
            </ul>
        </fieldset>
        <fieldset id="class-23">
            <legend> Class 23 - Javascript APIs</legend>
            <li>Declare arrays through its constructor or literal notation ([])</li>
            <li>You can also declare objects through its literal notation ({}). Meaning we use 'new {template}'' to make a instance of an object we created of literal notation</li>
            
            <p>The Class syntax of Objects was introduced to Javascript for people who were coming from class-based languages</p>
            <pre>
                class MakeCar{
                    constructor(carMake, carModel, carColor, numOfDoors){
                        this.make = carMake;
                        this.model = carModel;
                        this.color = carColor;
                        this.doors = numOfDoors;
                    }
                    honk(){
                        alert('BEEP BEEP FUCKER');
                    }
                    lock(){
                        alert(`Locked ${this.doors} door!`);
                    }
                }
            </pre>
            
            <p>APIs - A simple interface that allows us to do complex action! <br>
                It lets one thing communicate with another thing without having to know how things are implemented.
            </p>
            <p>A simple way to think about it is a remote to turn off a tv. Or a restaurant menu. <br>
                Both of these things serve one purpose where the user makes a request, and without the user knowing what's happening in the background, gives us the result. <br>
                In cs terms, a simple interface is our url, this means we are making a request using urls and it's going to a server to send us back a response.
            </p>
            <p>This means when we use APIs, we make a request(our app) to a server(API), in which the API will send a response through JSON(Javascript Object Notation - an object that comes back from the server). <br>
                With that object, we can manipulate however we want. 

                <pre>
                    Your App --- Request -> API
                    Your App &lt;-- JSON &lt;---- API
                </pre>
            </p>
            <li>Syntax for making a request with a URL: 
                <pre>
                    //Get a dog photo from the dog.ceo api and place the photo in our DOM
                    fetch('https://dog.ceo/api/breeds/image/random') //we use the fetch method for fetch requests to the url so it responds back
                        .then(res => res.json()) //whatever object we get back, parse response as JSON (we use a res var to represent response)
                        .then(data => {
                            console.log(data.message)
                            document.querySelector('#image').src = data.message
                        }) //console.log the data we got back. We are able to see the properties of that object as well. 

                        .catch(err => {console.log(`error ${err}`)})
                </pre>
            </li>
        </fieldset>
        <fieldset id="class-24">
            <legend>Class 24 - Github</legend>
            
        </fieldset>
        <fieldset id="class-25">
            <legend> Class 25 - Resume Building</legend>
        </fieldset>
        <fieldset id="class-26">
            <legend>Class 26 - More on APIs</legend>
            <pre>
                fetch(url that were fetching our api from)
                    .then(res => res.json()) //parse response as a json object (console.log this to get a promise object)
                    .then(data => console.log(data)) //grab the data from the JSON
                    .catch(err => console.log(`error ${err})) //console the error if there is one.
            </pre>
            <p>Lets do a scenario where we grab a drink from the api from an input response given</p>

            <pre>
                document.querySelector('button').addEventListener('click', getDrink)

                function getDrink(){
                    let drink = document.querySelector('input').value
                    fetch(`https://www.thecocktaildb.com/api/json/v1/1/search.php?s=${drink}`)
                    .then(res => res.json())
                    .then(data => {
                        console.log(data.drinks[0])
                        document.querySelector('h2').innerText= data.drinks[0].strDrink
                        document.querySelector('img').src = data.drinks[0].strInstructions 
                        document.querySelector('h3').innerText = data.drinks[0].strInstructions   
                    })
                }
            </pre>
        </fieldset>
        <fieldset id="class-27">
            <legend>Class 27</legend>
            <h3>Local Storage</h3>
            <p>Remember, We can use multiply query parameters on the url with the ampersand to attach them together. (&{dataParameter} =)</p>
            <p>Local Storage is an API, its simple methods allows us to do complex actions like storing stuff in user computers across browser sessions.</p>
            <p>Store data across browser sessions</p>
            <li><code>localStorage.reset()</code> - clears local storage</li>
            <li><code>localStorage.setItem('key', 'value')</code> - stores data</li>
            <li><code>localStorage.getItem('key')</code> - gets data (returns the value as a string)</li>
            <li><code>localStorage.removeItem('key')</code> - removes data</li>
            <pre>
                To do a counter on localStorage, we can use a function to grab the data and set that to variable for counter.
                function getCounter(){
                    let counter = Number(localStorage.getItem('counter'));
                    counter += 1;
                    localStorage.setItem('counter', counter);
                }
            </pre>
        </fieldset>
        <fieldset id="class-28">
            <legend>Class 28</legend>
            <p>More api practice</p>
        </fieldset>
        <fieldset id="class-29">
            <legend>Class 29</legend>
            <h3>Javascript Review</h3>

            <h4>The JS Way: Object-Oriented Programming</h4>
            <ul>
                <li style="list-style-type: none"><strong>Class Objects</strong></li>
                <li>A class is created with the <code>class</code> keyword, followed by the name of the class (usually starting with an uppercase letter).</li>
                <li>Contrary to object literals, there is no separating punctuation between the elements inside a class.</li>
                <li>A class can only contain methods, not data properties.</li>
                <li>Just like with object literals, the <code>this</code> keyword is automatically set by JavaScript inside a method and represents the object on which the method was called.</li>
                <li>A special method named <code>constructor()</code> can be added to a class definition. It is called during object creation and is often used to give it data properties.</li>
                <li>Objects are created from a class with the <code>new</code> keyword. It calls the constructor to initialize the object. This new object is an instance of the class object</li>
                <li>OOP - Object Oriented Programming => uses objects containing both variables and methods to create programs</li>
                <li>Classes emulate class-based OOP model on top of Javascript's own prototype-based model</li>
            </ul>
            <pre>
                    Syntax for class objects:

                    class MyClass {
                        constructor(param1, param2, ...) {
                            this.property1 = param1;
                            this.property2 = param2;
                            // ...
                        }
                        method1(/* ... */) {
                            // ...
                        }
                        method2(/* ... */) {
                            // ...
                        }
                        // ...
                    }

                    const myObject = new MyClass(arg1, arg2, ...);
                    myObject.method1(/* ... */);
                    // ...
            </pre>
            <ul>
                <li style="list-style-type: none"><strong>Prototypes</strong></li>
                <li>Javascript's OOP model is based on prototypes</li>
                <li>Prototypes are used to add properties and methods to an object</li>
                <li>Any javascript object can link (known as reference) to another object through the prototype </li>
                <li><code>Object.create(myPrototypeObject)</code> is used to create a prototype of an object; not to be confused with the class object</li>
                <li>If a property is not found in an object, it tries to find it in the prototype, and will go up the inheritance prototype chain</li>
                <li>The javascript <code>class</code> syntax is a more convenient way to create relationships between objects through prototypes. Creating a new object from the class is equivalent to creating a new object from the prototype</li>

                <pre>
                    const anObject = {
                        myProp: 2
                    };

                    // Create anotherObject using anObject as a prototype
                    const anotherObject = Object.create(anObject);

                    // Create yetAnotherObject using anotherObject as a prototype
                    const yetAnotherObject = Object.create(anotherObject);

                    // myProp is found in yetAnotherObject's prototype chain (in anObject)
                    console.log(yetAnotherObject.myProp); // 2

                    // myOtherProp canâ€™t be found in yetAnotherObject's prototype chain
                    console.log(yetAnotherObject.myOtherProp); // undefined
                </pre>
                <li>This type of relationship between JavaScript objects is called delegation: an object delegates part of its operation to its prototype.</li>
            </ul>

            <h4>The Secret Life of Objects</h4>
            <ul>
                <li style="list-style-type: none"><strong>Abstract Data Types</strong></li>
                <li>An abstract data type is a subprogram that contains complicated code reduced to a simple interface</li>
                <li>This limits bugs because changing parts of the code does not affect the rest of the program.</li>
                <li>We can also utilize object classes in multiple different programs, avoiding the need to rewrite the same code.</li>
                <li>Abstract data types have an interface - the collection of operations/methods that external code can perform on it. Anything beyond the interface are encapsulated in the implementation</li>
            </ul>
            <ul>
                <li style="list-style-type: none"><strong>Methods</strong></li>
                <li>Methods are properties that hold function values.</li>
                <li>When a function is called as a method of an object (through the syntax {object}.{method}() => this means the object is calling on its method), the <code>this</code> keyword refers to the object on which the method was called.
                    <pre>
                        function speak(line) {
                            console.log(`The ${this.type} rabbit says '${line}'`);
                        }
                        let whiteRabbit = {type: "white", speak};
                        let hungryRabbit = {type: "hungry", speak};

                        whiteRabbit.speak("Oh my fur and whiskers");
                        // â†’ The white rabbit says 'Oh my fur and whiskers'
                        hungryRabbit.speak("Got any carrots?");
                        // â†’ The hungry rabbit says 'Got any carrots?'
                    </pre>
                </li>
                <li>You can think of <code>this</code> as an extra parameter that is passed to the method, if we want to provide it explicitly, we can use the function's call method. Which treats the first argument as <code>this</code>, with later parameters for the method's parameters.
                    <pre>
                        speak.call(whiteRabbit, "Hurry");
                        // â†’ The white rabbit says 'Hurry'
                    </pre>
                </li>
                <li><code>this</code> can bind to the scope around them, including arrow functions (which cannot bind to their own this). All except function themselves, because each function has its own 'this' context. Adding a function in place of the arrow function will change the 'this' context to the function itself, which does not have a value property to reference from and returns undefined. 
                    <pre>
                        let finder = {
                            find(array) {
                                return array.some(v => v == this.value);
                            },
                            value: 5
                        };
                        console.log(finder.find([4, 5]));
                        // â†’ true
                    </pre>
                </li>
            </ul>
            <ul>
                <li style="list-style-type: none"><strong>Prototypes</strong></li>
                <li>Prototypes are objects that hold methods and properties, we can use to share to other objects because they are linked together.</li>
                <li><code>Object.getPrototypeOf(object)</code> - grabs the prototype of an object. You can also use <code>object.prototype</code></li>
                <li>in regular functions, <code>Object.create(object)</code> - creates a new object with a specific prototype from an existing object</li>
            </ul>
            <ul>
                <li style="list-style-type: none"><strong>Classes</strong></li>
                <li>To make an instance of a object, to have to make sure an object derive from the proper prototype and its available methods. This is what the constructor function does (includes this keywords and the new keyword).</li>
                <li>An easier way to do this is with <code>class</code> objects because it defines the prototype object inside it.</li>
                <li>Constructors are used to create instances of a class. It helps ensure the objects inherit the properties.</li>
            </ul>
            <ul>
                <li style="list-style-type: none"><strong>Private Properties</strong></li>
                <li>You can create private properties by prepending it with a hashtag and its existence will be entirely hidden from class declaration.</li>
                <li>It is possible to override inherited properties of the prototype by reassigning the property on the object instance itself. If you create other new instances, those ones will keep the original prototype properties.</li>
                <li>Overriding allows unique objects to express individual properties, while default properties are shared among all instances.

                    <pre>
                        An example of how useful overriding becomes is when we look at the .toString method.

                        console.log(Array.prototype.toString ==
                                    Object.prototype.toString);
                        // â†’ false
                        console.log([1, 2].toString());
                        // â†’ 1,2

                        The reason why they are not equal is because toString acts differently on arrays than objects. Array's toString has been overrided to return a string of elements separated by commas instead.
                    </pre>
                </li>
            </ul>
            <ul>
                <li style="list-style-type: none"><strong>Maps</strong></li>
                <li>Map is a data structure that associates values with other values. Which we already have this concept implemented through an object's key: value pair</li>
                <li>Because all objects inherit from the global object's prototype, toString for example is also a property within the map. 
                    <pre>
                        let ages = {
                            Boris: 39,
                            Liang: 22,
                            JÃºlia: 62
                        };

                        console.log(`JÃºlia is ${ages["JÃºlia"]}`);
                        // â†’ JÃºlia is 62
                        console.log("Is Jack's age known?", "Jack" in ages);
                        // â†’ Is Jack's age known? false
                        console.log("Is toString's age known?", "toString" in ages);
                        // â†’ Is toString's age known? true
                    </pre>
                For this reasons, using objects as maps is dangerous. However, we can create objects with no prototypes at all <code>object = Object.create(null)</code>
                </li>
                <li>Because objects require keys to be and implicitly converts all others to strings, we can use the Map constructor which accepts any data type for the keys or use Symbols. Though you can also use <code>Object.keys()</code> which only returns the properties of the object, without including the prototypes inherited or <code>Object.hasOwn()</code> - which also ignores the object's prototype and replaces the <code>in</code> operator. 

                    <pre>
                        let ages = new Map();
                        ages.set("Boris", 39);
                        ages.set("Liang", 22);
                        ages.set("JÃºlia", 62);

                        console.log(`JÃºlia is ${ages.get("JÃºlia")}`);
                        // â†’ JÃºlia is 62
                        console.log("Is Jack's age known?", ages.has("Jack"));
                        // â†’ Is Jack's age known? false
                        console.log(ages.has("toString"));
                        // â†’ false

                        set, get, and has, are part of the interface of the Map object. 
                    </pre>
                </li>
            </ul>
            <ul>
                <li style="list-style-type: none"><strong>Polymorphism</strong></li>
                <li>Polymorphic code is when you have multiple functions with the same name and similar interfaces (objects => methods and properties; functions => parameters and values), but they have different uses or implementations. Like our toString method being rewritten to fit arrays for example.</li>
            </ul>
            <ul>
                <li style="list-style-type: none"><strong>Getters, Setters, and Statics</strong></li>
                <li>Getters and setters are used to access and modify the value of an object's properties. They can hide function calls and the functions read as properties instead. </li>
                <li>You can use the static keyword when you want to define methods and properties that belong to the class itself but not to instances of the class. This is a powerful feature that allows you to encapsulate data and behavior that belong to the class. In other languages, this concept is the same. 
                    <pre>
                        class Person {
                            constructor(name, age) {
                                this.name = name;
                                this.age = age;
                            }
                            
                            static createAdult(name) {
                                return new Person(name, 18);
                            }
                        }

                        const adult = Person.createAdult("John");
                        console.log(adult); // Output: Person { name: 'John', age: 18 }


                        class Temperature {
                            constructor(celsius) {
                                this.celsius = celsius;
                            }
                            get fahrenheit() {
                                return this.celsius * 1.8 + 32;
                            }
                            set fahrenheit(value) {
                                this.celsius = (value - 32) / 1.8;
                            }

                            static fromFahrenheit(value) {
                                return new Temperature((value - 32) / 1.8);
                            }
                        }

                        let boil = Temperature.fromFahrenheit(212);
                        console.log(boil.celsius);
                        // â†’ 100

                        These case uses though can also be done by setting default values on the constructor. It's really more just organization for your code and limiting the amount of code shared to instances. 
                    </pre>
                </li>
            </ul>
            <ul>
                <li style="list-style-type: none"><strong>Symbols</strong></li>
                <li>Symbol data types are unique and cannot be created twice. They do not conflict with other data types.</li>
                <li>The strings you pass to a Symbol act like names and are merely just for identify which Symbol you're working with, so multiple Symbols can use the same name.</li>
                <li>Since Symbols are unique and usable as property names it makes them suitable for defining interfaces that can live with properties of the same name. 
                    <pre>
                        Take examples of the length property of strings and arrays:

                        const length = Symbol("length");
                        Array.prototype[length] = 0;

                        console.log([1, 2].length);
                        // â†’ 2
                        console.log([1, 2][length]);
                        // â†’ 0

                        So since array already has a length property, we can use Symbol's length property to create a new property with the same name using bracket notation instead.
                    </pre>
                </li>
            </ul>
            <ul>
                <li style="list-style-type: none"><strong>The Iterator Interface</strong></li>
                <li>You can make an object iterable through the '@@iterator' method, which is accessible through the <code>Symbol.iterator</code> property.
                    <pre>
                        const myIterable = {
                            [Symbol.iterator]() {
                                let step = 0;
                                return {
                                next() {
                                    step++;
                                    if (step === 1) {
                                    return { value: 'First', done: false };
                                    } else if (step === 2) {
                                    return { value: 'Second', done: false };
                                    } else {
                                    return { value: undefined, done: true };
                                    }
                                }
                                };
                            }
                        };

                        for (const value of myIterable) {
                        console.log(value);
                        }
                        // Output:
                        // First
                        // Second
                    </pre>
                </li>
                <li>If we break down what's happening inside the for/of loop for example, since it expects iterable objects, we know its a method named with a Symbol.iterator symbol. This means the syntax is really : for({key} of {object[Symbol.iterator]()})
                </li>
                <li>What does this mean? We can use the Symbol.iterator method to get the default iterator from an object. Then we can use that iterator to iterate over the object.
                    <pre>
                        EXAMPLE:
                        The default iterable object for arrays is Array.prototype.values();
                        The values() is the method actually called to create the iterator, Symbol.iterator only points to the appropriate default iterable object. 

                        const array = [1, 2, 3, 4, 5];

                        // Using Symbol.iterator to get the iterator function
                        const iteratorFunction = array[Symbol.iterator]();

                        console.log(iteratorFunction.next()); // { value: 1, done: false }
                        console.log(iteratorFunction.next()); // { value: 2, done: false }
                        console.log(iteratorFunction.next()); // { value: 3, done: false }
                        console.log(iteratorFunction.next()); // { value: 4, done: false }
                        console.log(iteratorFunction.next()); // { value: 5, done: false }
                        console.log(iteratorFunction.next()); // { value: undefined, done: true }

                        // This is the same as using array.values()
                        const valuesIterator = array.values();

                        console.log(valuesIterator.next()); // { value: 1, done: false }
                        console.log(valuesIterator.next()); // { value: 2, done: false }
                        console.log(valuesIterator.next()); // { value: 3, done: false }
                        console.log(valuesIterator.next()); // { value: 4, done: false }
                        console.log(valuesIterator.next()); // { value: 5, done: false }
                        console.log(valuesIterator.next()); // { value: undefined, done: true }
                    </pre>
                </li>
                <li>You'll notice the next method is part of the iterator interface/protocol, which is inside the default iterator object. It returns an object with value and done properties. 
                    <ul>
                        <li><code>value</code> - the value of the current iteration</li>
                        <li><code>done</code> - a boolean indicating whether the iteration is done or not</li>
                        <li><code>return</code> - an optional method to clean up the iterator if its terminated early, like through a <code>break</code>
                            <pre>
                                const iterableWithReturn = {
                                    [Symbol.iterator]() {
                                        let index = 0;
                                        return {
                                        next() {
                                            if (index < 3) {
                                            return { value: index++, done: false };
                                            } else {
                                            return { value: undefined, done: true };
                                            }
                                        },
                                        return() {
                                            console.log('Cleanup code executed');
                                            return { value: undefined, done: true };
                                        }
                                        };
                                    }
                                };

                                for (const value of iterableWithReturn) {
                                console.log(value);
                                if (value === 1) break;
                                }
                                // Output:
                                // 0
                                // 1
                                // Cleanup code executed
                            </pre>
                        </li>
                        <li><code>throw</code> - an optional method to throw an error</li>
                    </ul>
                </li>
                <li>Knowing the iterator interface, means we can create our own custom iterator, apart from javascript's built in iterators
                    <pre>
                        class ArrayIterator {
                            constructor(array) {
                                this.array = array;
                                this.index = 0;
                            }

                            next() {
                                if (this.index < this.array.length) {
                                return { value: this.array[this.index++], done: false };
                                } else {
                                return { value: undefined, done: true };
                                }
                            }

                            // Optional: Implement the return method for cleanup
                            return() {
                                console.log('Cleaning up...');
                                return { value: undefined, done: true };
                            }

                            // Optional: Implement the throw method for handling errors
                            throw(error) {
                                console.log('Error encountered:', error);
                                return { value: undefined, done: true };
                            }

                            [Symbol.iterator]() {
                                return this;
                            }
                        }

                        // Usage example:
                        const myArray = [1, 2, 3];
                        const iterator = new ArrayIterator(myArray);

                        for (const value of iterator) {
                        console.log(value); // Output: 1, 2, 3
                        }

                        // Manually using the iterator
                        const manualIterator = new ArrayIterator(myArray);
                        console.log(manualIterator.next()); // { value: 1, done: false }
                        console.log(manualIterator.next()); // { value: 2, done: false }
                        console.log(manualIterator.next()); // { value: 3, done: false }
                        console.log(manualIterator.next()); // { value: undefined, done: true }
                    </pre>
                </li>
                <li>Of course we also have javascript's built in iterators like arrays, strings, maps, and sets.</li>
            </ul>
            <ul>
                <li style="list-style-type: none"><strong>Inheritance</strong></li>
                <li>Inheritance allows classes to inherit properties and behavior from old classes. This can be done using the <code>extends</code> keyword which indicates the current class inherits from the other class. The inherited class is known as a superclass, while the receiving class is a subclass.</li>
                <li><code>super</code> - the constructor calls the constructor of its superclass through this keyword; This allows the subclass to inherit the behavior of the superclass, and you get to tell it which you want to inherit.</li>

                <pre>
                    // Superclass
                    class Animal {
                        constructor(name) {
                            this.name = name;
                        }

                        speak() {
                            console.log(`${this.name} makes a noise.`);
                        }
                        }

                        // Subclass
                        class Dog extends Animal {
                        constructor(name, breed) {
                            // Call the constructor of the superclass (Animal)
                            super(name);
                            this.breed = breed;
                        }

                        speak() {
                            // Call the speak method of the superclass
                            super.speak();
                            console.log(`${this.name} barks.`);
                        }

                        fetch() {
                            console.log(`${this.name} is fetching.`);
                        }
                    }

                    // Create an instance of Dog
                    const myDog = new Dog('Buddy', 'Golden Retriever');

                    // Use methods from both the superclass and subclass
                    myDog.speak();  // Buddy makes a noise.
                                    // Buddy barks.

                    myDog.fetch();  // Buddy is fetching.
                </pre>
                <li>Inheritance allows us to build slightly different data types from existing data types with relatively little work. It is a fundamental part of the object-oriented tradition, alongside encapsulation and polymorphism.</li>
            </ul>
            <ul>
                <li style="list-style-type: none"><strong>InstanceOf Operator</strong></li>
                <li>The <code>instanceof</code> operator can be used to check if an object is an instance of a class.</li>
            </ul>
        </fieldset>
        <fieldset id="class-30">
            <legend>Class 30 - OOP Principles</legend>
            <p>USE UNDERSTAND BUILD => Process of grasping concepts</p>
            <p>Remember classes basically input the constructor functions and the relevant prototype methods to make an object</p>
            <p>OOP allows us to structure our code to make it easier for beginners and other developers to understand our code, and it makes it easier for us to maintain our code</p>

            <h4>Encapsulation</h4>
            <p>Encapsulation is the process of storing functions (methods) with their corresponding variables (properties) into an object </p>
            <p>When we combine variables and functions into an object, we call that encapsulation. This means the scoping/grouping of variables and functions is restricted to the object, allowing us to keep our code readable and maintainable

                <pre>
                    //A simple object using encapsulation

                    const myObject = {
                        name: 'John',
                        age: 30,
                        greet() {
                            console.log('Hello, my name is ' + this.name);
                        }
                    };

                    // A constructor function using encapsulation

                    function AgencyContractor(hourlyRate, hours, taxRate){
                        this.hourlyRate = hourlyRate;
                        this.hours = hours;
                        this.taxRate = taxRate;
                        this.calculateProfit = function(){
                            return this.hourlyRate * this.hours * (1 - this.taxRate);
                        }
                        this.invoiceClient = () => {
                            return `Your invoice total is ${this.hourlyRate * this.hours}`
                        }
                    }
                </pre>
            </p>
            <ul>Why do this?: 
                <li>We can add new stuff easier</li>
                <li>We can read the code easier</li>
                <li>We are not afraid to make changes and cause unintended bugs</li>
            </ul>

            <hr>

            <h4>Abstraction</h4>
            <p>Abstraction is about hiding details and showing essentials</p>
            <p>Abstraction allows you to implement things without understanding or even thinking about all the hidden complexity.
            </p>
            <p>It lets us break down our code into smaller and more manageable pieces</p>
            <pre>
                //using closures to create private properties and methods for abstraction (constructor functions)

                function AgencyContractor(hourlyRate, hours, taxRate){
                    let rate = hourlyRate; //private
                    this.hours = hours;
                    this.taxRate = taxRate;
                    let calculateProfit = function(){
                        return rate * this.hours * (1 - this.taxRate);
                    }
                    this.invoiceClient = () => {
                        return `Your invoice total is ${rate * this.hours}`
                    }
                }

                const leon = new AgencyContractor(250, 160, .35);
                console.log(leon.invoiceClient()); //40000
                console.log(leon.hourlyRate); //undefined
                console.log(leon.calculateProfit()); //leon.calculateProfit is not a function 

                -----------------------------------------------------------
                //create private properties and methods (class functions)

                class AgencyContractor{
                    #rate; //private
                    constructor(hourlyRate, hours, taxRate){
                        this.#rate = hourlyRate; //private
                        this.hours = hours;
                        this.taxRate = taxRate;
                    }

                    #calculateProfit = () => {
                        return this.#rate * this.hours * (1 - this.taxRate);
                    }
                    invoiceClient = () => {
                        return `Your invoice total is ${this.#rate * this.hours}`
                    }
                }

                let leon = new AgencyContractor(250, 160, .35);

                console.log(leon.calculateProfit); //undefined

                YOU CAN ALSO USE GETTERS WITHOUT THE SETTER TO LIMIT USERS FROM ASSIGNING YOUR PROPERTIES. THEY CAN ONLY READ YOUR PROPERTIES.
            </pre>
            <ul> Why do this?:
                <li>We make smaller more manageable pieces of code</li>
            </ul>

            <hr>

            <h4>Inheritance</h4>
            <p>There is a difference between prototype-base inheritance and class-base inheritance:</p>
            <p>Inheritance allows us to share properties and methods through prototypes for all objects.</p>
            <p>In classes, we use inheritance to make a class(subclass) that inherits the properties and methods of another class (superclass). The properties and methods of the parent class (superclass) is shared through the keyword <code>extends</code> and the <code>super</code> keyword</p>
            <p><code>extends</code> - connects the subclass to the superclass while <code>super</code> - calls the constructor of the superclass</p>
            <p>Inheritance makes our code DRY. It makes specialized objects that inherit the properties and methods of their parent.</p>
            <pre>
                class Animal{
                    constructor(name){
                        this.name = name;
                    }
                    speak(){
                        console.log(`${this.name} makes a noise`);
                    }
                }

                class Dog extends Animal{
                    constructor(name, breed){
                        super(name);
                        this.breed = breed;
                    }
                }

                let simba = new Dog('Simba', 'Shepard');
            </pre>
            <p>It's important to note, that if we use private class properties (with hashtags), those properties are not accessible on child classes, even if you call them with a hashtag, it returns an error. Which means you would require a getter to grab that private value instead for your subclasses or the superclass must provide a way to expose it if it needs to be accessed from a subclass.
                
            The other option is just using underscores for private variables which you can still call from child classes but with an underscore prepended or without by using a getter. (of course you lose the strict private functionalities that # would otherwise provide)</p>

            <ul> Why do this?:
                <li>We keep our code DRY/eliminate redundant code</li>
                <li>It also further encapsulates logic and abstracts it from the rest of the code</li>
            </ul>

            <hr>

            <h4>Polymorphism</h4>
            <p>Polymorphism provides a way to perform a single action in different forms/ways. It provides the ability to call the same method on different Javascript objects. </p>
            <p>Code written to use an interface automatically knows how to work with any number of different objects that provide that interface.</p>

            <ul> Why do this?:
                <li>It helps us avoid conditionals and switch cases.</li>
            </ul>
        </fieldset>
    </body>
</html>

