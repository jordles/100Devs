<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-08">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="./styles.css">
    </head>
    <body>
        <fieldset id="class-01">
            <legend>Class 01</legend>
            <section id = "Coding">
            <h2>What is the Internet</h2>
                <p>Client-Server Model - client can make requests and server can serve them with a response<br>
                    frontend dev is client-end developers <br>
                    backend dev is server-end developers <br>
                    fullstack is both :3
                </p>
                <p>There are actually Internet cables around the world through the ocean floors, that make the client-server exchange possible. <br>
                These cables consist of 8 fiber wires, each fiber capable of transmitting 53 terabytes per sec</p>
                <p>bounce-rate - the rate is which people bounce from a website. The limit is 3 seconds for the client to make a request to the server and the server to fulfill and send the product back</p>
                <ul>Where do these client requests go? : 
                    <li>ISP - Internet Service Providers - they connect to your business place by giving us access to their fibers that connect to the big internet cables around the world</li>
                    <li>DNS - Domain Name System - it translates domain names (url) to IP addresses which our server is able to use and send/load data back to the client</li>
                </ul>
                <p>HTTP - Hypertext Transcript Protocol with TCP/IP - we are sending requests and responses through this protocol</p>
                <p>HTTPS - Hypertext Transcript Protocol Security - added security and encryption to protect requests and responses from the public</p>
                <p>VPN - Virtual Private Network - a computer that makes a request on the client's behalf, keeping anonymity <br>
                    The flow would be: Client makes a request that is encrypted > ISP > DNS > VPN : who decrypts and makes the request on your behalf
                </p>
            <hr>
            <p>Syntax - spelling and grammer rules</p>
            <h2>Structure of The Golden Rule (separation of concerns - organizes content)</h2>
                <p>HTML - Content/Structure/Backbone of our websites</p>
                <p>CSS - Style</p>
                <p>JS - Behavior/Interaction</p>
                <!--HTML and CSS are markup languages-->
            <hr>

            <h2>HTML5 - new biggest content: video, audio, canvas, geolocation, websockets (open peer to peer connections)</h2>
                <p>W3C - a standardized world wide web that have in common with all browsers</p>
                <p>HTML Syntax - consists of opening and closing tags with a tag name. <br>
                    We also have attributes that have values that do different things and the text or content inside the tags
                </p>
            </section>
            

            <h1>Homework</h1>
            <h2>Learning How to Learn</h2>
                <p>Focused(linear path focused based on knowledge known, like step by step) and Diffused Mode (used for new ideas or approaches)</p>
                <p>it uses a pinball analogy, with focused mode have more pins and closer in proximity to represent thoughts are more concentrated on one area before getting the solution. <br>
                    Diffused mode is a way of thinking more open-minded with your pins more spaced out so the concentration is more spread out and allows more freer thoughts with less intensity while maintaining some focus on your topic. <br>
                    Focused mode - a direct approach to solving problems using rational, sequential, analytical approaches. It is associated with concentrating abilities of the brain's prefrontal cortex, located right behind your forehead. <br>
                    the mode uses the 'octopus of attention' which describes slipping tentacles slipping into the 4 slots of working memory when necessary, to help make connections to information in the various parts of the brain. <br>
                    Working memory is the part of your memory that has to do with what you are immediately and consciously processing in your mind. <br>
                    Diffused mode- The brain makes random connections in a relaxed fashion. 
                    </outcome>
                    <pre>
                        flashlight set so that it casts its light very broadly, but not very strongly in any one area. 
                        (As opposed to the focused mode, which would have its light cast very strongly in a single area, but very weakly everywhere else.)
                    </pre>
                </p>
                <p>When you learn something new, new synapses are formed on the dendrites of the neurons in your brain</p>
            <hr>

            <h2>Procrastination, Memory, and Sleep </h2>
                <p>Pomodoro - a technique that encourages you to focus and study within a timer, then take a break after</p>
                <p>Long term memory vs working memory <br>
                    short term/working memory is like an inefficient blackboard and must be practiced over and over to be long term <br>
                    Long term memories is like a storage warehouse <br>
                    When you learn something new, you use youre working memory, which is capable of being long-term memory.
                </p>
                <p>There are 4 slots in the working memory, that are located behind the forehead, known as the prefrontal cortex</p>
                <p>Using diffused mode thinking, makes intentional connections with various parts of the brain instead</p>

                <p>spaced-repetition - a technique to space out repetition for studying through multiple days, instead of cramming</p>
                <p>being awake creates toxins, however when you sleep brain cells shrink and wash those toxins out. So sleeping can help the brain keep healthy</p>
            <hr>

            <h2>Chunking</h2>
                <p>When stressed your focused learning will suffer</p>
                <p>Chunks are pieces of information that are bound/group by meaning or use.</p>
                <p>Chunks are a network of neurons that are used to firing together</p>
                <p>Chunks can form from focused practice and repetition, the creation of strong memory traces</p>
                <p>Once you chunk(the main idea), you likely wont need to remember all the little underlying details</p>
                <p>using worked-out example might not be the best to form chunks because its too easy to focus too much on an individual step instead of observing the whole picture (connection between the steps)</p>
                <p>'Understanding' is a superglue that that helps hold underlying memory traces together</p>

                <ul>Steps to chunk:
                    <li>focused mode thinking on the chunk information (no distraction or multitasking, because they can use up the limited slots in your working memory)</li>
                    <li>understand the basic idea of the topic</li>
                    <li>do the problem, to prove your understanding</li>
                    <li>gaining content, means knowing when and how to use this chunk with practice</li>
                    <li>context is where top down(big picture) and bottom up learning(chunking) meet</li>
                    <li>top down(big picture) process allows you to see where what you are learning fits in</li>

                    <li>TO SUM UP: Focused Attention, Understanding, Practice </li>
                </ul>
                <p>Once a concept is chunked, it only takes one slot in working memory</p>
                <p>studies show simply practicing and recalling first is much more productive in learning that just rereading the material</p>
                <p>Recall - the mental retrieval of the key ideas is the best way to chunk and build 'neural hooks' or deeply engrain</p>
                <p>Often recalling / studying in a different place is better than constantly studying in the same place <br>
                because subconsciously you will associate your surroundings with the learning material, which can affect your memory to access them</p>
            
                <h2>Illusions of Competence: thinking youre learning, but youre actually not</h2>
                    <p>When you think seeing the solution helps you know the solution, but in reality you haven't thought through to enable neural circuitry </p>
                    <p>try highlighting main ideas before doing it everywhere, as that can convince yourself you have the concept in your memory to recall later</p>
                    <p>persistent rereading is another version of Illusions of Competence, convincing students that the material is in their mind, <br>
                        when recalling is a much more effective way to learn before rereading
                    </p>
                    <p>Mistakes help catch illusions of competence</p>
                    <p>Use deliberate practice to strengthen what you know at a higher level</p>

                <h2>Retrieval Practice:</h2>
                    <p>When you learn something, you create links in long-term memory. The process of repeatedly retrieving these links, is what strengthens them</p>
                    <p>The best way to use retrieval practice is through flashcards</p>
            <hr>

            <h2>Seeing the Bigger Picture</h2>
                <ul>Neuromodulators are chemicals that influence how a neuron responds with other neurons: <br>
                    <li>acetylcholine - formed for focused learning when you are paying close attention. <br>
                        These kinds of neurons activate circuits in synapsis that lead to long-term memory
                    </li>
                    <li>dopamine -controls our motivation, found in neurons on our brain stem (basal ganglia). <br>
                        They control reward learning and affects decision-making, and it received upon getting an unexpected reward. <br>
                        Dopamine helps motivation by placing future rewards as a goal, instead of immediate ones. It follows a promise and reward system <br>
                        A lack of dopamine neurons = lack of motivation and anhedonia - loss in interest in things that once gave pleasure. <br>
                        A severe loss of dopamine neurons causes resting tremor, slowless, rigidity, that is Parkinson's disease. <br>
                        Having no dopamine neurons can lead to catatonia. A complete lack of any movement. </li>
                    <li>serotonin - affects social life, closely linked to risk-taking behavior. </li>
                </ul>
                <p>The amygdala is the major center for cognition and emotion is located. Your emotions affect your memory and learning.</p>
                <hr>

                <p>Transfer - Chunks can be related/connect to other chunks that helps you learn more easily about chunks in different areas, and it helps you learn new concepts through chunks</p>
                <p>You brain can be thought of having a library of neural patterns/ chunks, and we can use diffuse mode thinking to help connect 2 or more chunks together to solve novel problems.  </p>

                <ul>Two ways to solve problems:
                    <li>sequential step-by-step reasoning - deliberately taking steps toward the solution; involves focused mode thinking</li>
                    <li>holistic intuition - linking several different thoughts; involves diffused mode thinking. <br>
                        Most difficult problems or concepts are grasped through intuition, because new ideas make a leap away from what you're familiar with, when can then be verified with focused mode thinking
                    </li>
                </ul>
                <p>Overlearning - continuing to practice after youve mastered what you can. This can be a good thing for automaticity, actions that becomes unconscious that its automatic <br>
                    Be careful of repetitive overlearning however, as this can be useless and bring about an illusion of competence when the material seems easy
                </p>
                <p>Deliberate practice - focusing on more difficult behavior </p>
                <p>Einstellung - initial thoughts or already formed chunks or neural pattern may prevent a better solution or idea from being found.</p>
                <p>Interleaving - practice jumping back and forth with problems and situations that require different techniques or strategies or variations. Helps you know when to use your techniques and learn more deeply. <br>
                    While spaced-repetition builds strong neural patterns, interleaving builds flexibility and creativity. 
                </p>
            <h2>Procrastination</h2>
                <p>Procrastination is like addiction - it offers excitement and relief from boring situations</p>
                <p>there are tasks where your brain goes 'zombie mode' where your brain is only semi-aware of the tasks it is doing (chunking can become habits) <br>
                    Or its a relaxed state your mind enters when you are performing common and habitual tasks<br>
                    You dont have to do focused mode thinking when you are performing a habit, it saves energy.
                </p>
                <ul>How Habits Form: 
                    <li>The cue - triggers 'zombie mode', a reaction </li>
                    <li>The routine - 'zombie mode', the actions you take when you receive a cue</li>
                    <li>the reward - habits continue because our cues cause the routines that eventually reward us</li>
                    <li>the belief - habits have power because of your belief in them. Your habits are based on your belief</li>

                    <li>finding good study habits that reward us is great for countering against procrastination</li>
                </ul>

                <p>Learn to focus on the process not the product</p>
                <p>Process- the flow of time and habits and action associated with that flow of time (steps to an outcome)</p>
                <p>Product - your outcome </p>
                <p>You prevent procrastination focus less on product and more on doing the process (develop habits that also complete the tasks you hate doing</p>
                <p>You will put less pressure on finishing a task and rather go through the flow of a process or a habit instead</p>
                <hr>

                <p>A trick to overriding a habit it to look to change your reaction to a cue </p>
                <p>The only place you need to apply willpower is to change your reaction to the cue</p>

                <ul>Habits through the lens of Procrastination
                    <li>The cue - location, time, how you feel, reactions</li>
                    <li>the routine - this is the reaction point where you must actively focus on rewiring your old habit - have a plan</li>
                    <li>the reward - once your brain expects the reward is when the rewiring takes place and allows you to form new habits</li>
                    <li>the belief - your beliefs can change your views and prevent procrastination</li>
                </ul>
                
                <p>Keep a weekly list of key tasks, with daily to do lists written the evening before because research show your subconscious will follow through with it better  </p>
                <p>Writing down tasks, helps free up working memory </p>
                <p>Writing the next day's task list before you go to sleep will help you to be able to complete the items on your task list the next day.</p>
            
                <ul>Summary:
                    <li>Keep a planner journal</li>
                    <li>Commit yourself to certain routines and tasks each day</li>
                    <li>delay rewards until you finish the task</li>
                    <li>Watch for procrastination cues</li>
                    <li>gain trust in your new system</li>
                    <li>have backup plans for when you still procrastinate</li>
                    <li>get the hardest negative task you dont want to do out of the way</li>
                </ul>
            <hr>
            <h2>Memory</h2>
                <p>Visual memory system in humans, vast and large in the brain, <br>
                    Images are important and contribute to memory because the images connect directly to your right brain's visual spacial centers. <br>
                    You can build stronger neural hooks by involving the senses with your memory. 
                </p>
                <p>The hippocampus is an important part of the brain for learning new things and memories of facts and events</p>
                <p>The lack of a hippocampus causes a process called memory consolidation (in which memories that are not set in stone in your memory are erased)</p>
                <p>Memories are living, breathing parts of the brain that are changing all the time </p>
                <p>reconsolidation - whenever you recall a memory and it changes by going from active state to inactive state in the long term memory <br>
                    It also occurs during sleep. 
                </p>
                <p>Consolidation - the process of taking memory from short term to long term </p>
                <p>Reactivation - the process of recalling a memory from long-term (so it went from an inactive state to an active one)</p>

                <p>In brains, there are supporting cells called glial cells. Astrocytes glial cells are the most abundant and provide nutrients to the neurons</p>
                
                <p>You can create meaningful groups using techniques like mnemonics or acronyms to make it easier to study with.</p>
                <p>Memory Palace technique - remember through places and writing on them like notepads,  useful for remembering unrelated items by associating each item with a different physical part of a place. <br>
                    It utilizes our visual & spatial memory systems and helps move information to long term. (its like an object with key value pairs, you use a key to find the value easily) 
                </p>
            
                <ul>Summary
                    Chunking Concepts:
                    <li>long-term memory, storage warehouse, practice and repeat to retrieve more easily, utilize spaced repetition</li>
                    <li>working-memory - a blackboard that fades quickly, 4 items in working memory, you can compact ideas to make larger chunks that take up less space in your working memory.</li>
                    <li>Visual and Spatial memory systems </li>
                    <li>meaningful groups & memory palace technique (easily simplify and chunk ideas and memories)</li>
                </ul>
            <hr>

            <h2>Renaissance Learning and Unlocking Your Potential </h2>
                <p>You can become a better learner by exercising, more effective than drugs.</p>
                <p>The visual cortex reaches maturity in childhood</p>
                <p>prefrontal cortex is the last to mature in the brain, involves complex analysis, social behavior, decision-making, and planning</p>

                <p>Knowledge collapse can occur when something that made sense to you is now confusing. This is a sign your mind is restructuring and building a firmer foundation of your understanding.</p>
        
                <p>Metaphor/Analogy - Easy way to remember and understand. The more visual the better. They describe simple ideas that relate to each other. <br>
                They usually give a physical understanding of the central idea behind the process or concept you want to understand. <br>
                They are also useful for getting out of Einstellung. They can make connections to neural structures that are already there</p>
                
                <h2>The Imposter Syndrome</h2>
                    <p>Everyone has different gifts, and imposter syndrome and inhibit you from doing your very best at your pace</p>
                    <p>people learn better by trying to make sense out of the information they perceive</p>
                    <p>having a smaller working memory means you can generalize your learning into more creative combinations. </p>
                
                <h2>Changing your Thoughts</h2>
                <p>Practice strengthens and reinforces connections between different brain regions</p>
                <p>People can enhance the development of their neuronal circuits by practicing thoughts that use those neurons</p>
                <p>We can make significant changes in our brain by changing how we think</p>
                <p>It's important to tune people out, just focus on yourself and do better</p>

            <h2>Renaissance Learning and Unlocking Your Potential 2</h2>
                <h2>Teamwork</h2>
                    <p>The right hemisphere of the brain helps us step back and put our work into focus of a bigger picture. <br>
                        The right side of the brain is important for getting into the right track and doing reality checks 
                    </p>
                    <p>The left hemisphere of the brain is far too focused, it provides a analytical and upbeat approach, but also rigidity, dogmatism, and egocentricity or overconfident personalities.</p>
                    <p>The best way to catch your blind spots and errors is to brainstorm and work with others working on the same topic.</p>
                    <p>Teamwork with others opens up a larger diffused mode thinking of discussions. Catch what you miss and cannot see within your own perspective <br>
                        Explaining to others, can also build your own understanding.
                    </p>
                <h2>A Test Checklist</h2>
                    <p>Testing helps concentrate the mind far better than just learning. </p>
                    <ul>A Checklist
                        <li>Did you make a serious effort to understand the text?</li>
                        <li>Did you work with classmates on homework problems?</li>
                        <li>Did you attempt to outline every problem solution</li>
                        <li>Did you participate actively in group discussions</li>
                        <li>Did you consult with instructor</li>
                        <li>Did you understand all your homework problems when they were handed in?</li>
                        <li>Did you ask in class for explanations of homework problem solutions that werent clear to you</li>
                        <li>If you had a study guide, did you carefully go through it before the test and convince yourself you could do everything on it?</li>
                        <li>Did you go over the study guide and problems with classmates and quiz one another?</li>
                        <li>If there was a review session before the test, did you attend and ask questions about anything you werent sure about?</li>
                        <li>Did you get a good night's sleep</li>
                    </ul>
                <h2>The Hard Start-Jump to Easy Technique</h2>
                    <p>Tough problems should actually be started first, since they take a lot of time. They also use a lot of diffuse mode thinking</p>
                    <p>However the best way is to start with a hard problem and immediately jump to the easy ones. <br>
                        Starting hard loads the first most difficult problem in mind and then switches attention away from it. These activities will activate the diffused mode thinking.
                        Complete the easy problem as much as you can, and move back to a difficult problem, to solve some steps that may be easier for you now, now that youve done some easy problems with the similar concept. Then move back to the easy problems again.
                    </p>
                    <p>This technique saves time and can be compared to a chef, multitasking by letting a steak cook while slicing tomatoes at the same time. <br>
                        The technique makes more efficient use of your brain by allowing different parts of the brain to work simultaneously on different thoughts. <br>
                        It guarantees that you will have a little work done on every problem, because you are switching back and forth to another and it prevents einstellung.
                    </p>
                    <p>Give your brain a chance to reflect on harder challenges</p>
                
                <h2>Final Helpful Hints for Tests</h2>
                    <p>If you shift your thinking when you face fear, panic, it can change your outlook of the situation.</p>
                    <p>You can deep breathing technique, where you place your hand on your stomach and draw a deep breath <br>
                        effectively counteracting the fight or flight responses, that fuels anxiety. You can practice this to make the action easier. 
                    </p>
                    <p>Try consciously relaxing your tongue </p>
                    <p>Always have a plan B for the alternative career just in case things dont work out. This reduces stress, and the best you can do is move forward</p>
                    <p>Blink, shift your attention, check your answer from different perspectives</p>

                
        </fieldset>
        <fieldset id="class-02"> 
            <legend>Class 02 - HTML</legend>
            <p>Software Engineer- someone who can write code, and knows the tools and systems behind the code, including the math and efficiency</p>
        
            <ul id="html-tags"> Tags:
                <li><code>br</code> - break a line of text, make a new line</li>
                <li><code>hr</code> - horizontal rule, a thematic break to separate content, makes a line</li>
                <li><code>ul/ol/li</code> - unordered/ordered lists/list items</li>
                <li><code>h1-h6</code> - heading tags based on importance </li>
                <li><code>p</code> - paragraph</li>
                <li><code>span</code> - short text</li>
                <li><code>pre</code> - preserve whitespace</li>
                <li><code>img ... src</code> - images, </li>
                <li><code>a ... href</code> - links</li>

                <hr id="Assisted Device Elements">
                <li><code>em</code> - emphasis</li>
                <li><code>strong</code> - important</li>

                <hr id="containing-elements">
                <li><code>div</code> - empty container</li>
                <li><code>section</code> - define a section, thematic grouping, typically used with a heading</li>
                <li><code>article</code> - independent, self-contained content for sharing and reusablity; forum/blog posts, user comments, product cards, newspaper articles</li>
                <li><code>aside</code> - ancillary or extra content (ads, sidebar); represents a portion of a document whose content is only indirectly related to the document's main content. Asides are frequently presented as sidebars or call-out boxes.</li>
                <li><code>header</code> - container for introductory content or a set of navigational links for document or section</li>
                <li><code>footer</code> - define a footer for a document or section; authorship, copyright, contact, sitemap, back to top</li>
                <li><code>figure</code> = specify self-contained content like illustrations, diagrams, photos, code listings <br>
                    <li><code>figcaption</code> = define a caption for a figure element; can be placed 1st or last child of the figure element</li>
                </li>
            </ul>

            <p>Replit or Glitch are great code editors that are free and online</p>
        </fieldset>
        <fieldset id="class-03">
            <legend>Class 03 - More HTML</legend>
            <p>CDN - content delivery network (images are heavy, in that it takes a while to download, but not with CDN), <br>
                CDNs places the image and puts it in servers around the world that are closer to you, so you dont have to wait that long for an image to load or other heavier files</p>
            <ul id="html-tags">
                <hr id="html-structure">
                <li><code><!DOCTYPE html></code> - define this document type is html</li>
                <li><code>html</code> - root tag,everything html goes inside here</li>
                <li><code>head</code> = contains metadata about the webpage, including information such as the webpageâ€™s title, scripts, and stylesheets. <br>
                    The head element is not visible to the user and is used to provide information to the browser and search engines about the webpage. <br>
                    everything the browser needs <br>
                    <pre>
                        <head>
                            <title>My Website</title>
                            <link rel="stylesheet" href="styles.css">
                            <script src="script.js"></script>
                            <style></style>
                            </head>
                    </pre>
                    
                </li>
                <li><code>body</code> = contains all the contents of an HTML document, everything the user needs</li>
                <hr>
                <li><code>nav</code> affects SEO by ignoring these repeated link names showing up, defines a set of navigational links, usually for major blocks of links (goes inside header)</li>
                <ul><code>form</code> - make a form element for your inputs
                    <li><code>action</code> = indicates where the form data should be sent ex:<code><form action="/submit-url"></form></code> is sent to the path of /submit-url</li>
                    <li><code>method</code> = The method attribute specifies how to send form-data to the URL specified in the action attribute. 
                        The form-data can be sent via a GET request as URL parameters (with method="get") or via a POST request as data in the request body (with method="post").
                    </li>
                    <ul><code>label</code> - a label to accompany your input, you can place text here before your input
                        <li><code>for</code> - an attribute for linking to your input's id attribute (you can prove its connected, when you click on the label text because it will focus on the input and indicate user input</li>
                    </ul>
                    <ul><code>input</code> => input element for adding different types of input
                        <li><code>type</code> - specify what type of input this is. Some types have built in checks and changes the way your input functions</li>
                        <li><code>id</code> - links to your label element's for attribute</li>
                    </ul>
                </ul>
            </ul>

            <ul>Progressive Enhancement
                <li>content - core of our website, html</li>
                <li>presentation - css</li>
                <li>client-side scripting - wrap our presentation and content, javascript</li>

                <p>Everything you add more and more things to your webpage, it makes it more heavy and it will increase the page load speed</p>
            </ul>

        </fieldset>
        <fieldset id="class-04">
            <legend>Class 04 - CSS</legend>
            <p>CSS can go inline (style attribute), in the head (style tag in head tag), in a separate file (css files)</p>
            <p>The only time you should be using inline styles in the professional world is emails, </p>
            <p>The only time you would use style in the head is with amazon, they have stated for every one second their page load increases they lose 1 million dollars a day. <br>
                Instead they use critical path css, which describes the essential css needed to load above the fold. <br>
                Loading above the fold means all the content you see before you start scrolling <br>
                Amazon will place that lil bit of css, enough to load above the fold, onto the head element. And the rest of the css, will be loaded in a separate css file</p>
        
            <p>To use a separate css file : use link with file path ==> from this html file, i want to go into this folder and then i want you to find this css file {folder/style.css}</p>

            <hr id="reading-css">
            <p>CSS Syntax - selectors, (property, property values) - declaration</p>
            <pre>
                The whole thing is called a rule.
                The p itself is called a selector.
                It is followed by a set of declarations in declaration block (the curly braces). 
                p{
                    color: red;
                    font-weight: bold;
                }
            </pre>
            <p>Since CSS(Cascading style sheets) is read from top to bottom, codes below can override what came before, also known as a Cascade</p>
        
            <hr id="css">
            <ul>
                <ul><code>color</code> - a css property to display a color to the element
                    <h3>RGB Color Model <code>rgb</code></h3>
                    <p>3 parameters representing red, green, and blue value. They range from 0 to 255. Half range (127) gets tierary colors. <br>
                    And combining any combo of the 3 colors gets you secondary colors, with the range varying the color shades.</p>
                    
                    <hr>
                    <h3>Hex Colors</h3>
                    <p>Hex color values start with a # character and take six characters from 0-9 and A-F (in that order). 
                        The first pair of characters represent red, the second pair represent green, 
                        and the third pair represent blue. For example, #4B5320. (there is an extra pair for alpha channel)
                    </p>
                    <p>00 is 0% of that color, and FF is 100%</p>

                    <hr>
                    <h3>HSL Color Model (Hue Saturation Lightness) <code>hsl</code></h3>
                    <p>The CSS hsl function accepts 3 values: a number from 0 to 360 for hue, a percentage from 0 to 100 for saturation, and 
                        a percentage from 0 to 100 for lightness.</p>
                    <p>If you imagine a color wheel, the hue red is at 0 degrees, green is at 120 degrees, and blue is at 240 degrees.</p>
                    <img src="http://thenewcode.com/assets/images/hsl-color-wheel.png" alt="color wheel">
                    <p>Saturation is the intensity of a color from 0%, or gray, to 100% for pure color.</p>
                    <p>Lightness is how bright a color appears, from 0%, or complete black, to 100%, complete white, with 50% being neutral.</p>
                    <ul>
                        <li><code>rgba</code> -  rgb with an alpha channel parameter (alpha must be decimal system 0 - 1.0)</li>
                        <li><code>hsla</code> - hsl with an alpha channel parameter</li>
                    </ul>
                </ul>
                <li><code>font-family</code> - set a font for the element. They can be linked to your html at head element with href and rel <br>
                    The font linking needs to come before our css link, because the css will most likely use the font (because of css reading from top to bottom) <br>
                    You can have fallbacks in your font-family, which are separated by commas, and finally your default fonts. 
                </li>
                <ul><code>font-weight</code> -  how thick the font is, these can be numbers or keywords
                    <li><code>lighter|normal|bold|bolder|100...900 </code></li>
                </ul> 
            </ul>

            <hr id="css-selectors">
            <li><code>#idname{}</code> - target id attributes in css with # (meant to be unique)</li>
            <li><code>.classname{}</code> - target class attributes in css with . (meant to be multiple)</li>
            <li><code>parent > child</code> -select an element that is the direct descendent of another element </li>
            <p>Specificity - the weight of some selectors take priority over others with less weight or points (regardless of cascade) <br>
                Important and inline styles are worth the most in points (think 1000) <br>
                IDs are (100) classes are (10) and tags are (1) <br>
                The cascade can help us from repeating code. 
            </p>
        </fieldset>
        <fieldset id="class-05">
            <legend>Class 05 - CSS layout</legend>
            <hr id="css-selecting-by-relationship">
                <li><code>parent > child {}</code> - select all child elements immediately inside the parent element (direct descendant)</li>
                <li><code>parent child {}</code> - select all child elements inside the parent element (any level deep)</li>
                <li><code>previous sibling + next sibling {}</code> - select the next sibling that has the previous sibling immediately coming after it</li>
            
            <hr id="box-model">
                <li><code>margins border - padding</code></li>

            <hr id="floats">
                <p>Floats fight as hard as they can to get into a corner (whether left or right)</p>
                <p>floats can be used to float containers next to each other with percentages(divide evenly with 4 decimals places to fit)</p>
                <p>Remember that floated object break out of the structure (as they float up), to solve this. Tell other elements to use <code>clear:both</code> to check if theres anything floating and will fit itself as if the floaters are actually there in structure</p>
                <p>The <code>clear</code> CSS property sets whether an element must be moved below (cleared) floating elements that precede it. The clear property applies to floating and non-floating elements.</p>
                <a href="https://stackoverflow.com/questions/4224476/floatright-reverses-order-of-spans">Handle right floats</a>
            
            <hr id="external css styles & hacks">
                <p>reset.css = resets everything on your styles</p>
                <p>normalize.css = default styling we're used to</p>
                <p>Box Model Hack - makes all box model sizing fit the border-box boundaries (box-sizing: border-box;)</p>
                <p>Clear Fix Hack - clears floats to ensure the element contains all its child elements and prevents the parent element from collapsing <br>
                    <code>
                        .clearfix:after{
                            content: ".";
                            display: block;
                            clear: both;
                            visibility: hidden;
                            line-height: 0;
                            height: 0;
                        }
                    </code>
                </p>
        </fieldset>
        <fieldset id="class-07">
            <legend>Class 07 - Responsive Websites</legend>
            <ul>What Makes a site Responsive?:
                <li>Fluidity - everything is a percentages, responding to your window size</li>
                <ul>Elasticity - using fonts and text to em & rem units (responsive unit of measure)
                    <li><code>em</code> - font size of the closest parent multiplied by number of ems</li>
                    <li><code>rem(root em)</code> - font size from the root (html element)</li>
                    <li>the default font size for most browsers is 16px. We can make the font size equal to 62.5% of 16px to get 10px</li>
                </ul>
                <ul>Content Decisions - decisions you make to show what content in different resolutions and screen sizes:
                    <img src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2020/09/media-query-anatomy.jpg?resize=1000%2C66&ssl=1">
                    <pre>
                        @media not|only mediatype and (mediafeature and|or|not mediafeature) {
                            CSS-Code;
                        }
                    </pre>
                    <ul style="list-style-type: none">
                        <li>keywords
                            <ul>
                                <li><code>not</code> - The not keyword inverts the meaning of an entire media query.</li>
                                <li><code>only </code> - only: The only keyword prevents older browsers that do not support media queries with media features from applying the specified styles. It has no effect on modern browsers.</li>
                                <li><code>and</code> - and: The and keyword combines a media feature with a media type or other media features.</li>
                            </ul>
                        </li>
                        <li>Media Type
                            <ul>
                                <li><code>all</code> - matches all devices of media</li>
                                <li><code>print</code> - matches documents view in print preview or any media for content that is intended to print</li>
                                <li><code>screen</code> - matches devices with a screen (it also means 0)</li>
                                <li><code>speech</code> - matches devices that read content audibly, like screenreaders</li>
                            </ul>
                        </li>
                        <li>Media Features
                            <ul>
                                <li><code>max-width|min-width</code> - apply css queries based on the viewport width
                                    <pre>
                                        @media(max-width: 960px){
                                            .card{
                                                padding: 2rem;
                                            }
                                        }
                                    </pre>
                                </li>
                            </ul>
                        </li>
                        <br>
                        <h3>Keywords</h3>
                        <li><code>not</code> - keyword inverts the meaning of the entire media query</li>
                        <li><code>only</code> - keyword prevents older browsers that do not support media queries; hide style sheets from older browsers </li>
                        <li><code>and|or</code> - keyword for combining/choosing media features</li>
                    </ul>
                </ul>
            </ul>

            <hr id="meta-tag-for-media">
            <li><code><meta name = "viewport" content="width=device-width, intial-scale=1.0"></code> <br>
                This basically tells the browser to make our media queries work on all devices, without it, mobile devices can't process our media queries. <br>
                It figures out the width of this screen regardless of device, and sets it to the width. The initial-scale is the zoom level <br>
                You can also set <code>user-scalable = "no"</code> but this is not great for accessibility since, it stops people from zooming with fingers. 
            </li>
        </fieldset>
        <fieldset id="class-08">
            <legend>Class 08 More CSS</legend>
            <p>1mb.club - all websites that keep their code light and not heavy, accessible to people who dont have high speed broadband or good internet</p>
        </fieldset>
        <fieldset id="class-11">
            <legend>CSS Layout & Flexbox</legend>
            <p>All additional details are placed on flexbox on my studyguide already</p>
            <li><code>previous sibling ~ general sibling</code> - selects all general sibling that are a sibling of the previous sibling</li>
        </fieldset>
        <fieldset id="class-12">
            <legend>Javascript</legend>
            <li>What is programming? - the task of writing those instructions in a language that the computer can understand</li>
        
            <li>Simple Circuit - when the switch is open, the led is off. When the switch is closed the light is on. (this is because when the switch is closed, it completes the circuit allows electricity through)</li>
            <p>We can represent the switch open(up) and close(down) with 0s and 1s</p>
            <p>With 2 switches, we can introduce logic when its 11, representing if switch 1 and switch 2 are closed, led is on</p>
            <ul class="js-code">
                <ul>JS Syntax:
                    <li>Semicolon, Brackets, Parentheses, Quotations, Ternary Operators, etc.</li>
                </ul>
                <p>Javascript rerenders the file/DOM itself, not the files you have for html and css</p>
                <p>The DOM(document object model) is a rerendering of the html and rerenders to its default when refreshed (recipes: html css), and represents a tree of nodes we can manipulate with javascript</p>
                
                <hr id="js-variables">
                <p>Variables tell our program to remember values for us to use later on and it stores a value.
                </p>
                <p>Declaration - declare a variable and it takes up space in the memory. You can then recall the variable at a later time</p>
                <p>Assignment - assign/store a value to the variable</p>
                <ul>Naming Conventions:
                    <li>camelCase - start with a lowercase, then every word after that start with uppercase</li>
                </ul>

                <hr id="js-data-types">
                <ul>Data Types:
                    <li>Strings - stores text, surrounded by quotes</li>
                    <li>Numbers - numerical (int, float(decimals)) signed (int: +4, float: -10.943)</li>
                </ul>

                <hr id="operators">
                <ul>Operators:
                    <li><code>Arithmetic: + - * / %</code></li>
                    <li><code>Logical: == === != !== > &lt; >= &lt;=</code></li>
                    <p>Know the difference between assigning and comparison = / ==</p>
                </ul>

                <ul class="escape-characters">
                    <p>Warning, these fall closely with css, and should be organized into that language instead, so we usually dont use this</p>
                    <li><code>\n</code> - newline</li>
                    <li><code>\t</code> - tab</li>
                </ul>
                <li><code>onclick = {myfunction}</code> - event that reads clicking events and passes the function</li>

                <ul class="js-class-projects">
                    <ul id="color-picker">
                        <li><code>document.getElementById('purple').onclick= partyPurple</code> - this sets an onclick event to a function to run when click.</li>
                    </ul>
                    <ul id="simple-calculator">
                        <ul><code>.addEventListener('{event}',{function you want to run when the event happens})</code> - add an event with a function that triggers when you activate it <br>
                            <li><code>click</code> - an event for clicking something</li>
                            <li><code>mouseover</code> - an event for hover</li>
                            <li><code>mouseout</code> - an event when exiting a hover </li>
                            <li><code>submit</code> - an event for form elements</li>
                        </ul>
                        <code style="white-space: pre-wrap; display: block;">
                            &lt;!DOCTYPE html&gt;
                            &lt;html lang=&quot;en&quot;&gt;
                                &lt;head&gt;
                                    &lt;meta charset=&quot;utf-8&quot;&gt;
                                    &lt;meta name=&quot;description&quot; content=&quot;Not so great calculator&quot;&gt;
                                    &lt;meta name=&quot;keywords&quot; content=&quot;calculator, bad, numbers&quot;&gt;
                                    &lt;title&gt;Not So Great Calculator&lt;/title&gt;
                                    &lt;!-- external CSS link --&gt;
                                    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot;&gt;
                                    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;
                                &lt;/head&gt;
                                &lt;body&gt;
                                    &lt;h1&gt;Not So Great Calculator&lt;/h1&gt;
                                    &lt;ul&gt;
                                        &lt;li id=&quot;pumpkin&quot;&gt;0&lt;/li&gt;
                                        &lt;li id=&quot;dominosPizza&quot;&gt;+3&lt;/li&gt;
                                        &lt;li id=&quot;zebra&quot;&gt;+9&lt;/li&gt;
                                        &lt;li id=&quot;cantThinkOfAnything&quot;&gt;-2&lt;/li&gt;
                                    &lt;/ul&gt;
                                    &lt;h2&gt;Result: &lt;span id=&quot;placeToPutResult&quot;&gt;&lt;/span&gt;&lt;/h2&gt;
                                    &lt;script type=&quot;text/javascript&quot; src=&quot;js/main.js&quot;&gt;&lt;/script&gt;
                                &lt;/body&gt;
                            &lt;/html&gt;

                            let total = 0;

                            document.querySelector('#pumpkin').addEventListener('click', makeZero);
                            document.querySelector('#dominosPizza').addEventListener('click', jumanji);
                            document.querySelector('#zebra').addEventListener('click', add9);
                            document.querySelector('#cantThinkOfAnything').addEventListener('click', sub2);

                            function makeZero() {
                                total = 0;
                                document.querySelector('#placeToPutResult').innerText = total;
                            }

                            function jumanji() {
                                total = total + 3;
                                document.querySelector('#placeToPutResult').innerText = total;
                            }

                            function add9() {
                                total = total + 9;
                                document.querySelector('#placeToPutResult').innerHTML = total;
                            }

                            function sub2() {
                                total = total - 2;
                                document.querySelector('#placeToPutResult').innerHTML = total;
                            }
                        </code>
                    </ul>
                    <ul id="day-of-the-week">
                        <code style="white-space: pre-wrap; display: block;">
                        &lt;!DOCTYPE html&gt;
                        &lt;html lang=&quot;en&quot;&gt;
                            &lt;head&gt;
                                &lt;meta charset=&quot;utf-8&quot;&gt;
                                &lt;meta name=&quot;description&quot; content=&quot;This app lets you know today is class, the weekend, or a boring day&quot;&gt;
                                &lt;meta name=&quot;keywords&quot; content=&quot;class, weekend, boring&quot;&gt;
                                &lt;title&gt;What is today?&lt;/title&gt;
                                &lt;!-- external CSS link --&gt;
                                &lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot;&gt;
                                &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;
                            &lt;/head&gt;
                            &lt;body&gt;
                                &lt;h1&gt;What is today?&lt;/h1&gt;
                                &lt;form&gt;
                                    &lt;label for=&quot;day&quot;&gt; Day of the week: &lt;/label&gt;
                                    &lt;input id=&quot;day&quot; type=&quot;text&quot; placeholder=&quot;Day of the week&quot;&gt;
                                &lt;/form&gt;
                                &lt;button id=&quot;check&quot; type=&quot;button&quot; name=&quot;button&quot;&gt;check&lt;/button&gt;
                                &lt;h2 id=&quot;placeToSee&quot;&gt;&lt;/h2&gt;
                                &lt;script type=&quot;text/javascript&quot; src=&quot;js/main.js&quot;&gt;&lt;/script&gt;
                            &lt;/body&gt;
                        &lt;/html&gt;

                        /******************************************
                        /* HOT GARBAGE - PLEASE DON'T MIMIC THIS CSS
                        /*******************************************/

                        /* Box Model Hack */
                        *{
                            box-sizing: border-box;
                        }

                        /******************************************
                        /* LAYOUT
                        /*******************************************/
                        h1, h2, form{
                        text-align: center;
                        }
                        button{
                        display: block;
                        margin: 20px auto;
                        }
                        ul{
                        width: 100px;
                        height: 200px;
                        border: 3px solid black;
                        margin: 0 auto;
                        list-style: none;
                        padding: 0;
                        }
                        li{
                        text-align: center;
                        width: 94px;
                        height: 49px;
                        border: 1px solid black;
                        }
                        h2{
                        font-size: 100px;
                        color: red;
                        font-weight: bold;
                        }
                        /******************************************
                        /* ADDITIONAL STYLES
                        /*******************************************/
                        
                        //JSSSSS
                        document.querySelector('#check').addEventListener('click', check)
    
                        function check() {
    
                        const day = document.querySelector('#day').value
    
                        //Conditionals go here
                        }
                    </code>
                    </ul>
                </ul>

                <ul class="js-function-expressions">
                    <li>Function Declaration - a way of creating a function with the following syntax: <br>
                        <code>function funcName(){}</code>
                    </li>
                    <li>Function Expression - another way to write function by creating a variable and placing a function inside it: <br>
                        <code>let variable = function(){}</code>
                    </li>
                    <p>No matter how its created the function is a value at the end of the day. When we place that value inside a function of itself, it will run regardless of the parenthesis</p>
                    <p>Assigning a variable to a variable with a function will copy the function that the variable has over to the other</p>
                    <p>A semicolon is only necessary in function expression because its not from the function but from the variable statement itself as part of the normal syntax.</p>
                    <p>A key difference is that a function declaration can be called earlier than it is defined and it is restricted within its own scope, <br>
                        but function expression is fully created when the execution reaches its right side so earlier code calling the function doesnt do anything though it isn't restricted by scope.
                    </p>
                    
                    <li>Ternary Operators => conditional ? {true} : {false} which we can use to assign a function expression if theres a choice to</li>
                    <li>Callback Functions - A callback is a function passed as an argument to another function</li>
                </ul>
                <ul class="js-arrow-functions">
                    <code>let func = (arg1, arg2, ..., argN) => expression;</code>
                    <p>if there are no arguments there still must be a parenthesis for the syntax of arrow functions</p>
                    <pre>
                        let age = prompt("What is your age?", 18);

                        let welcome = (age &lt; 18) ?
                        () => alert('Hello!') :
                        () => alert("Greetings!");

                        welcome();
                    </pre>
                
                </ul>
                
            </ul>
        </fieldset>
        
        <fieldset id="class-13">
            <legend>Class 13 - More Javascript Examples</legend>
            <p>Program - a set of instructions that you write to tell a computer what to do</p>
            <p>Programming - the task of writing instructions in a language that a computer can understand</p>

            <li><code>`${var}`</code> - template literals - allows variables in a string format using ticks</li>
            <ul class="js-class-projects">
                <p>The angry parent sim and bachelor is on my replit</p>
            </ul>
        </fieldset>
        <fieldset id="class-14">
            <p>Remember that statements execute from left to right, so incrementing positions on left or right can change how the variable outputs</p>
            <p>Functions - a method with sets of instructions that executes when called upon, they are the building blocks of a program <br>
                They can be declared(putting into memory) and assigned through parameters(place something in that bucket of memory), then called with the function and parenthesis
                
                <pre>
                    //function declaration
                    function name(parameters){
                        //body
                    }
                    //function call
                    name(arguments) //We are passing in arguments into the function. Which is received as a parameter, which is local to the function only. 
                </pre>
            
            </p>
        </fieldset>
        <fieldset id="class-15">
            <legend>Freelancing</legend>

            <ul>Templates -help us design a website quicker 
                <a href="https://html5up.net">Free & not shady</a>
                <a href="https://themeforest.net/"></a>
                <a href="https://wrapbootstrap.com/"></a>
            </ul>
            <ul>Hosting- hosting a website
                <a href="netlify.com/drop"></a>
                <p>If your client wants their personal domain, they can go for namecheap and IWantMyName for cheaper rates</p>
                <p>Tips for placing 100 Dev on resume, say it is an agency with a 100dev's academy training program</p>
            </ul>
            <ul>Proposals that you can send to clients to describe what you will provide of your services (what you will do and what you will send)
                Proposify & Panda Doc are both free...
                namecheap has a free logo maker
            </ul>
            <ul>Contracts - make contracts with your clients
                Contract Killer is Free

                Contract Requirements: 
                <pre>
                    (indefinition clause - not definite or uncertain)
                    We can't guarantee that our work will be error-free and so we can't be liable to you or any third-party for damages,
                    including lost profits, lost savings or other incidental, consequential or special damages, even if you've advised us of them.

                    We'll own any intellectual property rights we've developed prior to, or developed separately from this project and not paid for by you.
                    We'll own the unique combination of these elements that constitutes a complete design and we'll license its use to you
                    (ONCE PAID IN FULL), exclusively and in perpetuity for this project only, unless we agree otherwise. 
                    (I own all the code i wrote, i am merely giving you a unique license for you to use the work.)
                </pre>
            </ul>
            <p>Closing - ask what would they like their project to be then ask whats your ballpark budget, or estimated budget</p>
            <p>Always leave room to get help, tell your client the deadline is double of what you think will take you so in case something goes wrong you have time to fix it</p>
            <p>Password Manager - Lastpass Bitwarden Onepass</p>
        </fieldset>
        <fieldset id="class-16">
            <legend>Javascript Loops</legend>
            <p>Functions are simple sets of instructions, reusable, perform one action as a best practice, and form the basic building blocks of a program</p>
        </fieldset>
        <fieldset id="class-19">
            <legend>Javascript Arrays</legend>
            <li><code>forEach(function(currentValue, index, arr), thisValue(value passed to "this" on arr) )</code> => similar to map() but this method:
                <ul>
                    <li>mutates the original array and loops through the elements</li>
                    <li>the function itself will always return undefined</li>
                    <li>is unable to chain to other methods, because its undefined</li>
                </ul> 
            </li>
        </fieldset>
        <fieldset id="class-21">
            <legend>Class 21</legend>
            <p>You can make object with functions by setting them outside of the object or inside with object- key value syntax</p>
            <p>Remember if you dont have a return statement on your function it comes out as undefined</p>
        </fieldset>
        <fieldset id="class-22">
            <legend>Class 22 - Javascript Objects</legend>
            <p>Objects are a collection of variables(w/values) and functions</p>
            <p>Objects represent the attributes(variables) and behavior(methods) of something used in a program</p>
            <p>Object variables are called properties and object functions are called methods</p>
            <p>Object stores 'keyed' collections</p>

            <p>If we want to build multiples of the same object we can use constructors and prototypal inheritance</p>
            <p>We can use naming convention like uppercase on first word to indicate a function is a constructor:
                <pre>
                    function MakeCar(carMake, carModel, carColor, numOfDoors){
                        this.make = carMake
                        this.model = carModel
                        this.color carColor
                        this.doors = numOfDoors
                        this.honk = function(){
                            alert('BEEP BEEP FUCKER')
                        }
                        this.lock = function(){
                            alert(`Locked ${this.doors} doors!`)
                        }
                    }
                </pre>
            </p>
            <p>We can use the new keyword to make a new instance of an object.</p>
            <p>A prototype is another object that is used as a fallback source of properties <br>
                Meaning adding prototype properties adds directly to the template of an object (which do not show directly inside a constructor function, but internally instead)
            </p>
            <p>You actually save memory, by using prototypes, because its placed only on the constructor function itself, which through inheritance allows all instances of that function to share the same data, <br>
                compared to this.method() which would make many of the same methods, taking us memory. 
            </p>
            <p>A constructor's prototype provides a way to share methods and values among instances via the instance's private [[Prototype]] property.</p>
            <p>Prototypical inheritance or the general sense of inheritance chain is when an instance of an object checks itself to see if it has a property or method <br>
                If not, it can check the factory/template/constructor Object that made it and it can keep going up until the object global prototype. 
            </p>

            <p>Classes introduced from ES6 are just tactical sugar on top of constructors</p>

            <pre>
                function MakeSFCharacter(punch, kick, catchPhrase, specialMove){
                    this.punch = punch
                    this.kick = kick
                    this.catchPhrase = catchPhrase
                    this.specialMove = specialMove

                    this.taunt = () => console.log(`You can't handle my ${this.specialMove}`)
                    this.winning = () => console.log(`Haha! ${this.catchPhrase}`)
                    this.dash = () => console.log('Whoopp, missed me!')

                }

                let ryu = new MakeSFCharacter('high', 'high', 'Get OVER HERE', 'HADDDOOOOKKKEEENNNNN')
            </pre>

            <ul id="Object-Oriented Programming with Mosh">
                <li>Procedural Programming - program with a set of functions and variables. <br>
                    This is not ideal as changing functions can break others, leading to spaghetti code. <br>
                    Objects offer a way to group these properties(variables) and methods(functions) that operate on them into a single object.
                </li>
                <p>4 Pillars of Object-Oriented Programming - Encapsulation, Abstraction, Inheritance, and Polymorphism</p>
                <ul>
                    <li>Encapsulation - group related variables and functions that operate on them into objects and therefore reduce complexity and increase reusability. <br>
                    
                    Procedural has a lot more parameters for its functions, but OOP does not because it can directly grab the properties of the object so the function parameters can stay empty. 
                    With lower parameters, you can easily use and maintain the code. <br>
                    "The best functions are those with no parameters!" - Uncle Bob - Robert C Martin
                    </li>
                    <li>Abstraction - Hide the details and complexity and only show the essentials, Allows us to have a simpler interface and reduce impact of change (bugs) by grouping our functions together on our objects</li>
                    <li>Inheritance - eliminates redundant code, like making an instance of an object template ex: TextBox and Checkboxes inherit from HTMLElement object, which reduces the amount of code we need to write otherwise.</li>
                    <li>Polymorphism - many forms; through procedural programming we would have so many if else or switch/case statements, but with objects we can simplify the process</li>
                </ul>
                
            
                <li><code>{}</code> - object literal syntax</li>
                <li>Behavior - when an object has one or more methods</li>
                
                <p>When an object has a behavior, we should be using a factory/constructor function: <br>
                    <li>Factory - does not have a constructor, must return an object, simply create an instance without new keyword
                        <pre>
                            function createCircle(radius){
                                return{
                                    radius, //radius: radius
                                    draw: function(){
                                        console.log('draw')
                                    }
                                }
                            }
                        </pre>
                    </li>
                    <li>Constructor - uses this keyword, create an instance with new keyword, <br>
                        .constructor => references the function used to create an object<br>
                        The new keyword is important, because it creates an empty object, where it points to the this keyword. <br>
                        Without it, it would point to the window object and therefore assign global properties and variables and be affected by everything and create bugs.
                        We don't need to 'return this' statement as this is done by the new keyword. 

                        <pre>
                            function Circle(radius){
                                this.radius = radius;
                                this.draw = function(){
                                    console.log('draw');
                                }
                            }

                            WHAT IS HAPPENING INTERNALLY? 
                            Circle.call({}, # of arguments added explicitly) is the same as new Circle()
                            //this keyword references the empty object and passes arguments, (this is done in the background with new Circle(1))
                            Circle.apply({}, [1,2,3]) 
                            //allows you to pass an array as an argument to a function basically 

                            const another = new Circle(1);

                            WHAT IS HAPPENING INTERNALLY?
                            The 'new' keyword is used to create an empty object.
                            Then it sets 'this' to point to the object itself.
                            Return the object from the function directly. (so you don't need a return keyword)

                            Without the new keyword we define 'this' to the global object, which on the browser is window.
                        </pre>
                        <pre>
                            When you set an object with a variable internally this happens:
                            let x = {} means =>
                            let x = new Object{} //object itself here is a constructor function

                            same with other things:

                            new String(); //'', "", `` (string literals is easier than using a constructor)
                            new Boolean(); // true, false (boolean literals)
                            new Number(); // 1, 2, 3

                            BASICALLY EVERY OBJECT HAS A CONSTRUCTOR PROPERTY!!! The constructor references the function used to create the object itself. Using .constructor will give you the original function. 

                            even functions itself:

                            function Circle(radius){
                                this.radius = radius;
                                this.draw = function(){
                                    console.log('draw');
                                }
                            }
                            =>
                            const Circle = new Function('radius',
                            `   this.radius = radius;
                                this.draw = function(){
                                    console.log('draw');
                                }
                            `);
                            //if we create an instance from this 'new function' syntax, with the new keyword it would be the same thing. THIS MEANS FUNCTIONS ARE ALSO OBJECTS.
                        </pre>
                    </li>
                </p>

                <hr>

                <li>Value(Primitive) Types: Number, String, Boolean, Symbol, undefined, null</li>
                <li>Reference Types: Object, Functions, Arrays</li>
                <p>Primitives are copied/passed by their values, Objects are copied/passed by their reference in memory</p>
            
                <p>Objects are dynamic, meaning we have the option to add or remove properties to them through dot or bracket notation</p>
                <p>We generally use bracket notation when a property name is assigned somewhere else to a variable perhaps or the naming-convention does not work on dot notation</p>
                <li><code>delete {targetproperty}</code> - delete properties from objects</li>

                <hr>

                <li>Iterate over object properties: for(let x in {object}){}</li>
                <li><code>'{property}' in {object}</code> - checks to see if a property is in an object</li>
                <li><code>Object.keys({object})</code> - returns all the object's keys</li>

                <hr>

                <p>Abstraction - hide details, show only essentials</p>
                <p>You dont want all your objects implementation to be public, as any chance will require other changes in your code. <br>
                    But place inside a template function, and you only need to change one thing</p>
                <p>To show abstraction in object, you can make functions call other functions inside through Private properties and methods</p>

                <p>Private methods and properties: <br>
                    Can be made through assigning local variables instead of implementation detail as a this.property. <br> 
                    Thanks to closure, inner functions have access to outer function variables to use still because they stay in memory, which is different from scope which die when variables go out of scope. <br>
                    So when you check your members(properties and methods) of an object only 'this' properties and methods show up.
                    
                    <pre>
                        function Circle(radius){
                            this.radius = radius;

                            let defaultLocation = {x:0, y:0}; 
                            let computeOptimumLocation = function(factor){
                            //private because its a local variable. These are part of the closure of the draw function.
                            }

                            this.draw = function(){
                                computeOptimumLocation(0.1);
                                //defaultLocation
                                //this.radius
                                console.log('draw');
                            }
                        }
                    </pre>

                    <p>What if you want to simply want to call a private property or method though through dot or bracket notation? : <br>
                        Then you get use a get/set functions instead like <code>this.getDefaultLocation</code>, but you would have to type the appropriate keyword as well. <br>
                        You can then use: <br>
                        <li><code>Object.defineProperty(this, '{property}', 
                            { 
                                get: function(){return {property}} //getter functions read property, it is read-only
                                set: function(value){ {property} = value} //setter functions set property
                                //both of these are unique keywords for javascript
                            }
                        )
                        </code></li>
                        <pre>
                            Object.defineProperty(this, 'defaultLocation', {
                                get: function() { return defaultLocation}; 
                                set: function(value) { 
                                    if(!value.x || !value.y) 
                                        throw new Error('Invalid location.');
                                    
                                        defaultLocation = value;
                                }
                            });

                        </pre>
                        <pre>
                            function Stopwatch(){
                                let startTime, endTime, running, duration = 0;
                                this.start = () => {
                                    if(running)
                                        throw new Error('Stopwatch has already started.');
                                    
                                    running = true;
                                    startTime = new Date(); //start timer
                                }
                            
                                this.stop = () => {
                                    if(!running)
                                        throw new Error('Stopwatch is not started.');
                                    
                                    running = false;
                                    endTime = new Date(); //end timer (Date is from the global object)

                                    const seconds = (endTime.getTime() - startTime.getTime()) / 1000;
                                    duration += seconds;
                                }

                                this.reset = function(){
                                    startTime, endTime, running, duration = 0;
                                }

                                Object.defineProperty(this, 'duration', {
                                    get: function() {return duration;}
                                })
                            }

                        </pre>
                    </p>
                </p>
            </ul>
        </fieldset>
        <fieldset id="class-23">
            <legend> Class 23 - Javascript APIs</legend>
            <li>Declare arrays through its constructor or literal notation ([])</li>
            <li>You can also declare objects through its literal notation ({}). Meaning we use 'new {template}'' to make a instance of an object we created of literal notation</li>
            
            <p>The Class syntax of Objects was introduced to Javascript for people who were coming from class-based languages</p>
            <pre>
                class MakeCar{
                    constructor(carMake, carModel, carColor, numOfDoors){
                        this.make = carMake;
                        this.model = carModel;
                        this.color = carColor;
                        this.doors = numOfDoors;
                    }
                    honk(){
                        alert('BEEP BEEP FUCKER');
                    }
                    lock(){
                        alert(`Locked ${this.doors} door!`);
                    }
                }
            </pre>
            
            <p>APIs - A simple interface that allows us to do complex action! <br>
                It lets one thing communicate with another thing without having to know how things are implemented.
            </p>
            <p>A simple way to think about it is a remote to turn off a tv. Or a restaurant menu. <br>
                Both of these things serve one purpose where the user makes a request, and without the user knowing what's happening in the background, gives us the result. <br>
                In cs terms, a simple interface is our url, this means we are making a request using urls and it's going to a server to send us back a response.
            </p>
            <p>This means when we use APIs, we make a request(our app) to a server(API), in which the API will send a response through JSON(Javascript Object Notation - an object that comes back from the server). <br>
                With that object, we can manipulate however we want. 

                <pre>
                    Your App --- Request -> API
                    Your App &lt;-- JSON &lt;---- API
                </pre>
            </p>
            <li>Syntax for making a request with a URL: 
                <pre>
                    //Get a dog photo from the dog.ceo api and place the photo in our DOM
                    fetch('https://dog.ceo/api/breeds/image/random') //we use the fetch method for fetch requests to the url so it responds back
                        .then(res => res.json()) //whatever object we get back, parse response as JSON (we use a res var to represent response)
                        .then(data => {
                            console.log(data.message)
                            document.querySelector('#image').src = data.message
                        }) //console.log the data we got back. We are able to see the properties of that object as well. 

                        .catch(err => {console.log(`error ${err}`)})
                </pre>
            </li>
        </fieldset>
        <fieldset id="class-24">
            <legend>Class 24 - Github</legend>
            
        </fieldset>
        <fieldset id="class-25">
            <legend> Class 25 - Resume Building</legend>
        </fieldset>
        <fieldset id="class-26">
            <legend>Class 26 - More on APIs</legend>
            <pre>
                fetch(url that were fetching our api from)
                    .then(res => res.json()) //parse response as a json object (console.log this to get a promise object)
                    .then(data => console.log(data)) //grab the data from the JSON
                    .catch(err => console.log(`error ${err})) //console the error if there is one.
            </pre>
            <p>Lets do a scenario where we grab a drink from the api from an input response given</p>

            <pre>
                document.querySelector('button').addEventListener('click', getDrink)

                function getDrink(){
                    let drink = document.querySelector('input').value
                    fetch(`https://www.thecocktaildb.com/api/json/v1/1/search.php?s=${drink}`)
                    .then(res => res.json())
                    .then(data => {
                        console.log(data.drinks[0])
                        document.querySelector('h2').innerText= data.drinks[0].strDrink
                        document.querySelector('img').src = data.drinks[0].strInstructions 
                        document.querySelector('h3').innerText = data.drinks[0].strInstructions   
                    })
                }
            </pre>
        </fieldset>
        <fieldset id="class-27">
            <legend>Class 27</legend>
            <h3>Local Storage</h3>
            <p>Remember, We can use multiply query parameters on the url with the ampersand to attach them together. (&{dataParameter} =)</p>
            <p>Local Storage is an API, its simple methods allows us to do complex actions like storing stuff in user computers across browser sessions.</p>
            <p>Store data across browser sessions</p>
            <li><code>localStorage.clear()</code> - clears local storage</li>
            <li><code>localStorage.setItem('key', 'value')</code> - stores data</li>
            <li><code>localStorage.getItem('key')</code> - gets data (returns the value as a string)</li>
            <li><code>localStorage.removeItem('key')</code> - removes data</li>
            <pre>
                To do a counter on localStorage, we can use a function to grab the data and set that to variable for counter.
                function getCounter(){
                    let counter = Number(localStorage.getItem('counter'));
                    counter += 1;
                    localStorage.setItem('counter', counter);
                }
            </pre>
        </fieldset>
        <fieldset id="class-28">
            <legend>Class 28</legend>
            <p>More api practice</p>
        </fieldset>
        <fieldset id="class-29">
            <legend>Class 29</legend>
            <h3>Javascript Review</h3>

            <h3>Homework</h3>
            <hr>
            <h4>The JS Way: Object-Oriented Programming</h4>
            <ul>
                <li style="list-style-type: none"><strong>Class Objects</strong></li>
                <li>A class is created with the <code>class</code> keyword, followed by the name of the class (usually starting with an uppercase letter).</li>
                <li>Contrary to object literals, there is no separating punctuation between the elements inside a class.</li>
                <li>A class can only contain methods, not data properties.</li>
                <li>Just like with object literals, the <code>this</code> keyword is automatically set by JavaScript inside a method and represents the object on which the method was called.</li>
                <li>A special method named <code>constructor()</code> can be added to a class definition. It is called during object creation and is often used to give it data properties.</li>
                <li>Objects are created from a class with the <code>new</code> keyword. It calls the constructor to initialize the object. This new object is an instance of the class object</li>
                <li>OOP - Object Oriented Programming => uses objects containing both variables and methods to create programs</li>
                <li>Classes emulate class-based OOP model on top of Javascript's own prototype-based model</li>
            </ul>
            <pre>
                    Syntax for class objects:

                    class MyClass {
                        constructor(param1, param2, ...) {
                            this.property1 = param1;
                            this.property2 = param2;
                            // ...
                        }
                        method1(/* ... */) {
                            // ...
                        }
                        method2(/* ... */) {
                            // ...
                        }
                        // ...
                    }

                    const myObject = new MyClass(arg1, arg2, ...);
                    myObject.method1(/* ... */);
                    // ...
            </pre>
            <ul>
                <li style="list-style-type: none"><strong>Prototypes</strong></li>
                <li>Javascript's OOP model is based on prototypes</li>
                <li>Prototypes are used to add properties and methods to an object</li>
                <li>Any javascript object can link (known as reference) to another object through the prototype </li>
                <li><code>Object.create(myPrototypeObject)</code> is used to create a prototype of an object; not to be confused with the class object</li>
                <li>If a property is not found in an object, it tries to find it in the prototype, and will go up the inheritance prototype chain</li>
                <li>The javascript <code>class</code> syntax is a more convenient way to create relationships between objects through prototypes. Creating a new object from the class is equivalent to creating a new object from the prototype</li>

                <pre>
                    const anObject = {
                        myProp: 2
                    };

                    // Create anotherObject using anObject as a prototype
                    const anotherObject = Object.create(anObject);

                    // Create yetAnotherObject using anotherObject as a prototype
                    const yetAnotherObject = Object.create(anotherObject);

                    // myProp is found in yetAnotherObject's prototype chain (in anObject)
                    console.log(yetAnotherObject.myProp); // 2

                    // myOtherProp canâ€™t be found in yetAnotherObject's prototype chain
                    console.log(yetAnotherObject.myOtherProp); // undefined
                </pre>
                <li>This type of relationship between JavaScript objects is called delegation: an object delegates part of its operation to its prototype.</li>
            </ul>

            <h4>The Secret Life of Objects</h4>
            <ul>
                <li style="list-style-type: none"><strong>Abstract Data Types</strong></li>
                <li>An abstract data type is a subprogram that contains complicated code reduced to a simple interface</li>
                <li>This limits bugs because changing parts of the code does not affect the rest of the program.</li>
                <li>We can also utilize object classes in multiple different programs, avoiding the need to rewrite the same code.</li>
                <li>Abstract data types have an interface - the collection of operations/methods that external code can perform on it. Anything beyond the interface are encapsulated in the implementation</li>
            </ul>
            <ul>
                <li style="list-style-type: none"><strong>Methods</strong></li>
                <li>Methods are properties that hold function values.</li>
                <li>When a function is called as a method of an object (through the syntax {object}.{method}() => this means the object is calling on its method), the <code>this</code> keyword refers to the object on which the method was called.
                    <pre>
                        function speak(line) {
                            console.log(`The ${this.type} rabbit says '${line}'`);
                        }
                        let whiteRabbit = {type: "white", speak};
                        let hungryRabbit = {type: "hungry", speak};

                        whiteRabbit.speak("Oh my fur and whiskers");
                        // â†’ The white rabbit says 'Oh my fur and whiskers'
                        hungryRabbit.speak("Got any carrots?");
                        // â†’ The hungry rabbit says 'Got any carrots?'
                    </pre>
                </li>
                <li>You can think of <code>this</code> as an extra parameter that is passed to the method, if we want to provide it explicitly, we can use the function's call method. Which treats the first argument as <code>this</code>, with later parameters for the method's parameters.
                    <pre>
                        speak.call(whiteRabbit, "Hurry");
                        // â†’ The white rabbit says 'Hurry'
                    </pre>
                </li>
                <li><code>this</code> can bind to the scope around them, including arrow functions (which cannot bind to their own this). All except function themselves, because each function has its own 'this' context. Adding a function in place of the arrow function will change the 'this' context to the function itself, which does not have a value property to reference from and returns undefined. 
                    <pre>
                        let finder = {
                            find(array) {
                                return array.some(v => v == this.value);
                            },
                            value: 5
                        };
                        console.log(finder.find([4, 5]));
                        // â†’ true
                    </pre>
                </li>
            </ul>
            <ul>
                <li style="list-style-type: none"><strong>Prototypes</strong></li>
                <li>Prototypes are objects that hold methods and properties, we can use to share to other objects because they are linked together.</li>
                <li><code>Object.getPrototypeOf(object)</code> - grabs the prototype of an object. You can also use <code>object.prototype</code></li>
                <li>in regular functions, <code>Object.create(object)</code> - creates a new object with a specific prototype from an existing object</li>
            </ul>
            <ul>
                <li style="list-style-type: none"><strong>Classes</strong></li>
                <li>To make an instance of a object, to have to make sure an object derive from the proper prototype and its available methods. This is what the constructor function does (includes this keywords and the new keyword).</li>
                <li>An easier way to do this is with <code>class</code> objects because it defines the prototype object inside it.</li>
                <li>Constructors are used to create instances of a class. It helps ensure the objects inherit the properties.</li>
            </ul>
            <ul>
                <li style="list-style-type: none"><strong>Private Properties</strong></li>
                <li>You can create private properties by prepending it with a hashtag and its existence will be entirely hidden from class declaration.</li>
                <li>It is possible to override inherited properties of the prototype by reassigning the property on the object instance itself. If you create other new instances, those ones will keep the original prototype properties.</li>
                <li>Overriding allows unique objects to express individual properties, while default properties are shared among all instances.

                    <pre>
                        An example of how useful overriding becomes is when we look at the .toString method.

                        console.log(Array.prototype.toString ==
                                    Object.prototype.toString);
                        // â†’ false
                        console.log([1, 2].toString());
                        // â†’ 1,2

                        The reason why they are not equal is because toString acts differently on arrays than objects. Array's toString has been overrided to return a string of elements separated by commas instead.
                    </pre>
                </li>
            </ul>
            <ul>
                <li style="list-style-type: none"><strong>Maps</strong></li>
                <li>Map is a data structure that associates values with other values. Which we already have this concept implemented through an object's key: value pair</li>
                <li>Because all objects inherit from the global object's prototype, toString for example is also a property within the map. 
                    <pre>
                        let ages = {
                            Boris: 39,
                            Liang: 22,
                            JÃºlia: 62
                        };

                        console.log(`JÃºlia is ${ages["JÃºlia"]}`);
                        // â†’ JÃºlia is 62
                        console.log("Is Jack's age known?", "Jack" in ages);
                        // â†’ Is Jack's age known? false
                        console.log("Is toString's age known?", "toString" in ages);
                        // â†’ Is toString's age known? true
                    </pre>
                For this reasons, using objects as maps is dangerous. However, we can create objects with no prototypes at all <code>object = Object.create(null)</code>
                </li>
                <li>Because objects require keys to be and implicitly converts all others to strings, we can use the Map constructor which accepts any data type for the keys or use Symbols. Though you can also use <code>Object.keys()</code> which only returns the properties of the object, without including the prototypes inherited or <code>Object.hasOwn()</code> - which also ignores the object's prototype and replaces the <code>in</code> operator. 

                    <pre>
                        let ages = new Map();
                        ages.set("Boris", 39);
                        ages.set("Liang", 22);
                        ages.set("JÃºlia", 62);

                        console.log(`JÃºlia is ${ages.get("JÃºlia")}`);
                        // â†’ JÃºlia is 62
                        console.log("Is Jack's age known?", ages.has("Jack"));
                        // â†’ Is Jack's age known? false
                        console.log(ages.has("toString"));
                        // â†’ false

                        set, get, and has, are part of the interface of the Map object. 
                    </pre>
                </li>
            </ul>
            <ul>
                <li style="list-style-type: none"><strong>Polymorphism</strong></li>
                <li>Polymorphic code is when you have multiple functions with the same name and similar interfaces (objects => methods and properties; functions => parameters and values), but they have different uses or implementations. Like our toString method being rewritten to fit arrays for example.</li>
            </ul>
            <ul>
                <li style="list-style-type: none"><strong>Getters, Setters, and Statics</strong></li>
                <li>Getters and setters are used to access and modify the value of an object's properties. They can hide function calls and the functions read as properties instead. </li>
                <li>You can use the static keyword when you want to define methods and properties that belong to the class itself but not to instances of the class. This is a powerful feature that allows you to encapsulate data and behavior that belong to the class. In other languages, this concept is the same. 
                    <pre>
                        class Person {
                            constructor(name, age) {
                                this.name = name;
                                this.age = age;
                            }
                            
                            static createAdult(name) {
                                return new Person(name, 18);
                            }
                        }

                        const adult = Person.createAdult("John");
                        console.log(adult); // Output: Person { name: 'John', age: 18 }


                        class Temperature {
                            constructor(celsius) {
                                this.celsius = celsius;
                            }
                            get fahrenheit() {
                                return this.celsius * 1.8 + 32;
                            }
                            set fahrenheit(value) {
                                this.celsius = (value - 32) / 1.8;
                            }

                            static fromFahrenheit(value) {
                                return new Temperature((value - 32) / 1.8);
                            }
                        }

                        let boil = Temperature.fromFahrenheit(212);
                        console.log(boil.celsius);
                        // â†’ 100

                        These case uses though can also be done by setting default values on the constructor. It's really more just organization for your code and limiting the amount of code shared to instances. 
                    </pre>
                </li>
            </ul>
            <ul>
                <li style="list-style-type: none"><strong>Symbols</strong></li>
                <li>Symbol data types are unique and cannot be created twice. They do not conflict with other data types.</li>
                <li>The strings you pass to a Symbol act like names and are merely just for identify which Symbol you're working with, so multiple Symbols can use the same name.</li>
                <li>Since Symbols are unique and usable as property names it makes them suitable for defining interfaces that can live with properties of the same name. 
                    <pre>
                        Take examples of the length property of strings and arrays:

                        const length = Symbol("length");
                        Array.prototype[length] = 0;

                        console.log([1, 2].length);
                        // â†’ 2
                        console.log([1, 2][length]);
                        // â†’ 0

                        So since array already has a length property, we can use Symbol's length property to create a new property with the same name using bracket notation instead.
                    </pre>
                </li>
            </ul>
            <ul>
                <li style="list-style-type: none"><strong>The Iterator Interface</strong></li>
                <li>You can make an object iterable through the '@@iterator' method, which is accessible through the <code>Symbol.iterator</code> property.
                    <pre>
                        const myIterable = {
                            [Symbol.iterator]() {
                                let step = 0;
                                return {
                                next() {
                                    step++;
                                    if (step === 1) {
                                    return { value: 'First', done: false };
                                    } else if (step === 2) {
                                    return { value: 'Second', done: false };
                                    } else {
                                    return { value: undefined, done: true };
                                    }
                                }
                                };
                            }
                        };

                        for (const value of myIterable) {
                        console.log(value);
                        }
                        // Output:
                        // First
                        // Second
                    </pre>
                </li>
                <li>If we break down what's happening inside the for/of loop for example, since it expects iterable objects, we know its a method named with a Symbol.iterator symbol. This means the syntax is really : for({key} of {object[Symbol.iterator]()})
                </li>
                <li>What does this mean? We can use the Symbol.iterator method to get the default iterator from an object. Then we can use that iterator to iterate over the object.
                    <pre>
                        EXAMPLE:
                        The default iterable object for arrays is Array.prototype.values();
                        The values() is the method actually called to create the iterator, Symbol.iterator only points to the appropriate default iterable object. 

                        const array = [1, 2, 3, 4, 5];

                        // Using Symbol.iterator to get the iterator function
                        const iteratorFunction = array[Symbol.iterator]();

                        console.log(iteratorFunction.next()); // { value: 1, done: false }
                        console.log(iteratorFunction.next()); // { value: 2, done: false }
                        console.log(iteratorFunction.next()); // { value: 3, done: false }
                        console.log(iteratorFunction.next()); // { value: 4, done: false }
                        console.log(iteratorFunction.next()); // { value: 5, done: false }
                        console.log(iteratorFunction.next()); // { value: undefined, done: true }

                        // This is the same as using array.values()
                        const valuesIterator = array.values();

                        console.log(valuesIterator.next()); // { value: 1, done: false }
                        console.log(valuesIterator.next()); // { value: 2, done: false }
                        console.log(valuesIterator.next()); // { value: 3, done: false }
                        console.log(valuesIterator.next()); // { value: 4, done: false }
                        console.log(valuesIterator.next()); // { value: 5, done: false }
                        console.log(valuesIterator.next()); // { value: undefined, done: true }
                    </pre>
                </li>
                <li>You'll notice the next method is part of the iterator interface/protocol, which is inside the default iterator object. It returns an object with value and done properties. 
                    <ul>
                        <li><code>value</code> - the value of the current iteration</li>
                        <li><code>done</code> - a boolean indicating whether the iteration is done or not</li>
                        <li><code>return</code> - an optional method to clean up the iterator if its terminated early, like through a <code>break</code>
                            <pre>
                                const iterableWithReturn = {
                                    [Symbol.iterator]() {
                                        let index = 0;
                                        return {
                                        next() {
                                            if (index < 3) {
                                            return { value: index++, done: false };
                                            } else {
                                            return { value: undefined, done: true };
                                            }
                                        },
                                        return() {
                                            console.log('Cleanup code executed');
                                            return { value: undefined, done: true };
                                        }
                                        };
                                    }
                                };

                                for (const value of iterableWithReturn) {
                                console.log(value);
                                if (value === 1) break;
                                }
                                // Output:
                                // 0
                                // 1
                                // Cleanup code executed
                            </pre>
                        </li>
                        <li><code>throw</code> - an optional method to throw an error</li>
                    </ul>
                </li>
                <li>Knowing the iterator interface, means we can create our own custom iterator, apart from javascript's built in iterators
                    <pre>
                        class ArrayIterator {
                            constructor(array) {
                                this.array = array;
                                this.index = 0;
                            }

                            next() {
                                if (this.index < this.array.length) {
                                return { value: this.array[this.index++], done: false };
                                } else {
                                return { value: undefined, done: true };
                                }
                            }

                            // Optional: Implement the return method for cleanup
                            return() {
                                console.log('Cleaning up...');
                                return { value: undefined, done: true };
                            }

                            // Optional: Implement the throw method for handling errors
                            throw(error) {
                                console.log('Error encountered:', error);
                                return { value: undefined, done: true };
                            }

                            [Symbol.iterator]() {
                                return this;
                            }
                        }

                        // Usage example:
                        const myArray = [1, 2, 3];
                        const iterator = new ArrayIterator(myArray);

                        for (const value of iterator) {
                        console.log(value); // Output: 1, 2, 3
                        }

                        // Manually using the iterator
                        const manualIterator = new ArrayIterator(myArray);
                        console.log(manualIterator.next()); // { value: 1, done: false }
                        console.log(manualIterator.next()); // { value: 2, done: false }
                        console.log(manualIterator.next()); // { value: 3, done: false }
                        console.log(manualIterator.next()); // { value: undefined, done: true }
                    </pre>
                </li>
                <li>Of course we also have javascript's built in iterators like arrays, strings, maps, and sets.</li>
            </ul>
            <ul>
                <li style="list-style-type: none"><strong>Inheritance</strong></li>
                <li>Inheritance allows classes to inherit properties and behavior from old classes. This can be done using the <code>extends</code> keyword which indicates the current class inherits from the other class. The inherited class is known as a superclass, while the receiving class is a subclass.</li>
                <li><code>super</code> - the constructor calls the constructor of its superclass through this keyword; This allows the subclass to inherit the behavior of the superclass, and you get to tell it which you want to inherit.</li>

                <pre>
                    // Superclass
                    class Animal {
                        constructor(name) {
                            this.name = name;
                        }

                        speak() {
                            console.log(`${this.name} makes a noise.`);
                        }
                        }

                        // Subclass
                        class Dog extends Animal {
                        constructor(name, breed) {
                            // Call the constructor of the superclass (Animal)
                            super(name);
                            this.breed = breed;
                        }

                        speak() {
                            // Call the speak method of the superclass
                            super.speak();
                            console.log(`${this.name} barks.`);
                        }

                        fetch() {
                            console.log(`${this.name} is fetching.`);
                        }
                    }

                    // Create an instance of Dog
                    const myDog = new Dog('Buddy', 'Golden Retriever');

                    // Use methods from both the superclass and subclass
                    myDog.speak();  // Buddy makes a noise.
                                    // Buddy barks.

                    myDog.fetch();  // Buddy is fetching.
                </pre>
                <li>Inheritance allows us to build slightly different data types from existing data types with relatively little work. It is a fundamental part of the object-oriented tradition, alongside encapsulation and polymorphism.</li>
            </ul>
            <ul>
                <li style="list-style-type: none"><strong>InstanceOf Operator</strong></li>
                <li>The <code>instanceof</code> operator can be used to check if an object is an instance of a class.</li>
            </ul>
        </fieldset>
        <fieldset id="class-30">
            <legend>Class 30 - OOP Principles</legend>
            <p>USE UNDERSTAND BUILD => Process of grasping concepts</p>
            <p>Remember classes basically input the constructor functions and the relevant prototype methods to make an object</p>
            <p>OOP allows us to structure our code to make it easier for beginners and other developers to understand our code, and it makes it easier for us to maintain our code</p>

            <h4>Encapsulation</h4>
            <p>Encapsulation is the process of storing functions (methods) with their corresponding variables (properties) into an object </p>
            <p>When we combine variables and functions into an object, we call that encapsulation. This means the scoping/grouping of variables and functions is restricted to the object, allowing us to keep our code readable and maintainable

                <pre>
                    //A simple object using encapsulation

                    const myObject = {
                        name: 'John',
                        age: 30,
                        greet() {
                            console.log('Hello, my name is ' + this.name);
                        }
                    };

                    // A constructor function using encapsulation

                    function AgencyContractor(hourlyRate, hours, taxRate){
                        this.hourlyRate = hourlyRate;
                        this.hours = hours;
                        this.taxRate = taxRate;
                        this.calculateProfit = function(){
                            return this.hourlyRate * this.hours * (1 - this.taxRate);
                        }
                        this.invoiceClient = () => {
                            return `Your invoice total is ${this.hourlyRate * this.hours}`
                        }
                    }
                </pre>
            </p>
            <ul>Why do this?: 
                <li>We can add new stuff easier</li>
                <li>We can read the code easier</li>
                <li>We are not afraid to make changes and cause unintended bugs</li>
            </ul>

            <hr>

            <h4>Abstraction</h4>
            <p>Abstraction is about hiding details and showing essentials</p>
            <p>Abstraction allows you to implement things without understanding or even thinking about all the hidden complexity.
            </p>
            <p>It lets us break down our code into smaller and more manageable pieces</p>
            <pre>
                //using closures to create private properties and methods for abstraction (constructor functions)

                function AgencyContractor(hourlyRate, hours, taxRate){
                    let rate = hourlyRate; //private
                    this.hours = hours;
                    this.taxRate = taxRate;
                    let calculateProfit = function(){
                        return rate * this.hours * (1 - this.taxRate);
                    }
                    this.invoiceClient = () => {
                        return `Your invoice total is ${rate * this.hours}`
                    }
                }

                const leon = new AgencyContractor(250, 160, .35);
                console.log(leon.invoiceClient()); //40000
                console.log(leon.hourlyRate); //undefined
                console.log(leon.calculateProfit()); //leon.calculateProfit is not a function 

                -----------------------------------------------------------
                //create private properties and methods (class functions)

                class AgencyContractor{
                    #rate; //private
                    constructor(hourlyRate, hours, taxRate){
                        this.#rate = hourlyRate; //private
                        this.hours = hours;
                        this.taxRate = taxRate;
                    }

                    #calculateProfit = () => {
                        return this.#rate * this.hours * (1 - this.taxRate);
                    }
                    invoiceClient = () => {
                        return `Your invoice total is ${this.#rate * this.hours}`
                    }
                }

                let leon = new AgencyContractor(250, 160, .35);

                console.log(leon.calculateProfit); //undefined

                YOU CAN ALSO USE GETTERS WITHOUT THE SETTER TO LIMIT USERS FROM ASSIGNING YOUR PROPERTIES. THEY CAN ONLY READ YOUR PROPERTIES.
            </pre>
            <ul> Why do this?:
                <li>We make smaller more manageable pieces of code</li>
            </ul>

            <hr>

            <h4>Inheritance</h4>
            <p>There is a difference between prototype-base inheritance and class-base inheritance:</p>
            <p>Inheritance allows us to share properties and methods through prototypes for all objects.</p>
            <p>In classes, we use inheritance to make a class(subclass) that inherits the properties and methods of another class (superclass). The properties and methods of the parent class (superclass) is shared through the keyword <code>extends</code> and the <code>super</code> keyword</p>
            <p><code>extends</code> - connects the subclass to the superclass while <code>super</code> - calls the constructor of the superclass</p>
            <p>Inheritance makes our code DRY. It makes specialized objects that inherit the properties and methods of their parent.</p>
            <pre>
                class Animal{
                    constructor(name){
                        this.name = name;
                    }
                    speak(){
                        console.log(`${this.name} makes a noise`);
                    }
                }

                class Dog extends Animal{
                    constructor(name, breed){
                        super(name);
                        this.breed = breed;
                    }
                }

                let simba = new Dog('Simba', 'Shepard');
            </pre>
            <p>It's important to note, that if we use private class properties (with hashtags), those properties are not accessible on child classes, even if you call them with a hashtag, it returns an error. Which means you would require a getter to grab that private value instead for your subclasses or the superclass must provide a way to expose it if it needs to be accessed from a subclass.
                
            The other option is just using underscores for private variables which you can still call from child classes but with an underscore prepended or without by using a getter. (of course you lose the strict private functionalities that # would otherwise provide)</p>

            <ul> Why do this?:
                <li>We keep our code DRY/eliminate redundant code</li>
                <li>It also further encapsulates logic and abstracts it from the rest of the code</li>
            </ul>

            <hr>

            <h4>Polymorphism</h4>
            <p>Polymorphism provides a way to perform a single action in different forms/ways. It provides the ability to call the same method on different Javascript objects. </p>
            <p>Code written to use an interface automatically knows how to work with any number of different objects that provide that interface.</p>

            <ul> Why do this?:
                <li>It helps us avoid conditionals and switch cases.</li>
            </ul>
        </fieldset>
        <fieldset id="class-33">
            <legend>Class 33 - Secrets to Landing Your First Tech Job</legend>
            <ul>
                <li style="list-style-type: none">Crafting your Story</li>
                <li>Why are you here?</li>
                <li>Passing the Sniff Test</li>
                <li>Can You code? Do i want to work with you? (check my work and experience)</li>
                <li>My Story: I come from a background in art, design and tech. When i came across Web Development, I immediately loved the designing aspect of it and problem solving. I'm focused on building cool, creative, and intuitive user experiences that people can enjoy and love.</li>
                <li>Github : 
                    <a href="https://rahuldkjain.github.io/gh-profile-readme-generator/">Profile Generator</a>
                    <a href="https://github.com/alecortega/portfolio-template">READ ME Template</a>
                </li>
                <li>HitList: Find open roles that are in your area. 
                    <ul>
                        <li>Find a hiring manager, follow them on twitter, find email (hunter.io), ask for coffee chat, send thank you, get recommendation. </li>
                        <li>Find the engineer on the team , and do the same thing</li>
                        <li>Find the recruiter, and do the same thing</li>
                    </ul>
                </li>
                <li>60 well networked applications</li>
                <li>30 High Value Apps - Custom Resume, Cover Letter, and Story</li>
                <li>10 Premium Apps - custom everything plus landing page, tweets, blog, and project. (Build an app that sells/is appropriate for the company)</li>

            </ul>

            <h3>Homework</h3>
            <hr>

            <fieldset id="MDN: Async / Await">
                <legend>MDN: Async / Await</legend>
                <ul>
                    <li>A reminder that synchronous programming is slow because the browser is stepping through the program line by line, waiting for each line to execute.</li>
                    <li>A promise is a Response object returned by an asynchronous function, representing the current state of the operation. </li>
                    <li>Since the operation often isn't finished immediately, a promise can be represented in one of three states: pending (the initial state of your fetch), fulfilled (then() is called), or rejected (catch() is called).</li>
                    <li>XMLHttpRequest API is replaced with fetch() API, which makes an HTTP request asynchronously. </li>
                    <li>If we console.log the fetch() we would get a promise object, then when settled, we would get a Response object. 
                        <pre>
                            const fetchPromise = fetch(
                            "https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json",
                            );

                            console.log(fetchPromise); //Promise {&lt;pending&gt;}

                            fetchPromise.then((response) => {
                            console.log(`Received response: ${response.status}`);
                            });

                            console.log("Started requestâ€¦"); //this might come first, before then() executes
                        </pre>
                    </li>
                    <li><code>RESPONSE.json()</code> - parses the body text as JSON and returns it as a javascript object. json() is also async. </li>
                    <li><code>PROMISE.then(resolved, rejected)</code> is one of the methods thats stores a callback function and returns another promise (Response) object. This will allow you chain promises together called Promise Chaining. The callback function will be called when the async function is successful if only one parameter is given. If there are two, the second parameter acts as the rejected callback for the promise. 

                        <pre>
                            fetchPromise
                                .then((response) => response.json())
                                .then((data) => {
                                    console.log(data[0].name);
                                });
                        </pre>
                    </li>
                    <li><code>PROMISE.catch()</code> is one of the methods that stores a callback function and returns another promise (Response) object. This method will be called when the async function fails. 
                        
                        <pre>
                            fetchPromise
                                .then((response) => {
                                    if (!response.ok) {
                                    throw new Error(`HTTP error: ${response.status}`);
                                    }
                                    return response.json();
                                })
                                .then((data) => {
                                    console.log(data[0].name);
                                })
                                .catch((error) => {
                                    console.error(`Could not get products: ${error}`);
                                });
                        </pre>
                    </li>
                    <li><code>Promise.resolve()</code> resolves a promise, which is not the same as settling. It returns a promise whose eventual state depends on another promise, thenable object, or other values. Is the parameter is empty, the returned promise will be fulfilled already. </li>
                    <li><code>Promise.all([PROMISE1, PROMISE2, ...])</code> - allows you to wait for multiple promises to complete (also chaining them together) It takes in an array of promises and returns a single promise. This means promise.all is fulfilled if all promises in the array are fulfilled, while if any of the promises fail, the promise.all will be rejected.
                    
                        <pre>
                            const fetchPromise1 = fetch(
                            "https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json",
                            );
                            const fetchPromise2 = fetch(
                            "https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found",
                            );
                            const fetchPromise3 = fetch(
                            "https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json",
                            );

                            Promise.all([fetchPromise1, fetchPromise2, fetchPromise3])
                            .then((responses) => {
                                for (const response of responses) {
                                console.log(`${response.url}: ${response.status}`);
                                }
                            })
                            .catch((error) => {
                                console.error(`Failed to fetch: ${error}`);
                            });
                        </pre>
                    </li>
                    <li><code>Promise.any([PROMISE1, PROMISE2, ...])</code> this method is similar to Promise.all, but it only returns the first fulfilled promise, rejecting when all promises in the array are rejected.</li>
                    <li>IMPORTANT TERMS : Settled - a promise that is either fulfilled or rejected
                        A promise is <strong>resolved</strong> if it is settled, or 'locked in' to follow the state of another promise. 
                    </li>
                    <li><code>Promise.allSettled([PROMISE1, PROMISE2, ...])</code> - fulfills when all promises in the array are settled</li>
                    <li><code>Promise.race([PROMISE1, PROMISE2, ...])</code> - settles when any of the promises in the array is settled (fulfilled or rejected)</li>

                    <hr>

                    <li><code>async</code> this keyword is used to create an asynchronous function</li>
                    <li><code>await</code> this keyword is used to wait for the promise to be settled; The fulfilled value of the promise is returned, or the rejected value is thrown. Await will pause the execute of the async function until the promise settles, making the asynchronous code behave more synchronously. (sequential asynchronous)</li>
                    <li><code>await fetch()</code> returns a fully complete Response object instead of a Promise and makes fetch act like a synchronous function. Why? Because <code>await</code> pauses the execution of the function until the promise settles, the same way we use then() and catch() to pause the execution of an async function. <br>
                        This means then() and the await keyword are both methods to handle asynchronous operations. 
                    </li>
                    <li>Async/await is a syntactic sugar that simplifies the use of promises. It is a syntactic sugar that makes writing asynchronous code much easier. 
                    It makes the code look more synchronous, and avoids the need to create promise chains. 

                        <pre>
                        async function fetchProducts() {
                            try {
                                // after this line, our function will wait for the `fetch()` call to be settled
                                // the `fetch()` call will either return a Response or throw an error
                                const response = await fetch(
                                "https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json",
                                );
                                if (!response.ok) {
                                throw new Error(`HTTP error: ${response.status}`);
                                }
                                // after this line, our function will wait for the `response.json()` call to be settled
                                // the `response.json()` call will either return the parsed JSON object or throw an error
                                const data = await response.json();
                                console.log(data[0].name);
                            } catch (error) {
                                console.error(`Could not get products: ${error}`);
                            }
                        }

                        fetchProducts();
                        -----------------------------------------------------------------------
                        //reminder that async functions always return a Promise object
                        async function fetchProducts() {
                            const response = await fetch(
                                "https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json",
                            );
                            if (!response.ok) {
                                throw new Error(`HTTP error: ${response.status}`);
                            }
                            const data = await response.json();
                            return data;
                        }

                        const promise = fetchProducts();
                        promise
                            .then((data) => {
                                console.log(data[0].name);
                            })
                            .catch((error) => {
                                console.error(`Could not get products: ${error}`);
                            });
                        </pre>
                    </li>
                </ul>
            </fieldset>
            <fieldset id="The Async Await Episode">
                <legend>The Async Await Episode</legend>
                <ul>
                    <li>Event Loop: One the first run, run all synchronous code and queue up asynchronous events to be executed later. The code keeps going and when the asynchronous event is done, it is callbacked to the event loop. If it is a macro task like set timeout or set interval, it will be executed at the next event loop tick. If it is a micro task like a fulfilled promise, it will be executed as soon as it can, before the start of the next event loop. </li>
                    <li>Macrotasks - block the main thread until theyre finished. </li>
                    <li>Microtasks - run as soon as it can and do not block the main thread. It means all async operations are microtasks.</li>
                    <li>Fetch allows us to hit an http endpoint and get a response in the form of a promise</li>
                    <li>Promises can be chained together. </li>
                    <li>then() for fulfilled promises, catch() for rejected promises</li>
                    <li>Asynchronous code allows you to perform long-running tasks without blocking the main thread. </li>
                    <li><code>new Promise(resolve, reject)</code> - we can create our own promises through the constructor. </li>
                    <li>Creating new promises creates a microtask, because it is not part of the event loop
                        <pre>
                            const codeBlocker = () => {
                                return new Promise((resolve, reject) => {
                                    let i = 0;
                                    while(i < 10000000) {i++};
                                    resolve('billion loops done');
                                });
                            }
                        </pre>

                        However, the task of the loop is still happening on the main thread, its only the resolving of the promise that is a microtask. 

                        <pre>
                            const codeBlocker = () => {
                                return Promise.resolve().then(() => {
                                    let i = 0;
                                    while(i < 10000000) {i++};
                                    return 'billion loops done';
                                })
                            }
                        </pre>

                        Promise.resolve() will return a promise that is resolved / settled (sets a promise to a settled state). So codeblocker as a function is a microtask / asynchronous. 
                    </li>
                    <li>chaining promises with <code>then</code> can seem messy so we can use async/await which is syntactical sugar that makes the code read like synchronous code</li>

                    <li><code>async</code> keywords is used to create an asynchronous function, this function will return a Promise object of the value (even if you are returning something with the return keyword). The async keyword replaces the need to use Promise.resolve()
                    
                        <pre>
                            const getFruit = async (name) => {
                                const fruits = {
                                    apple: 'ðŸŽ',
                                    banana: 'ðŸŒ',
                                    orange: 'ðŸŠ'
                                }
                                return fruits[name];
                            }

                            is the same as :

                            const getFruit = (name) => {
                                const fruits = {
                                    apple: 'ðŸŽ',
                                    banana: 'ðŸŒ',
                                    orange: 'ðŸŠ'
                                }
                                return Promise.resolve(fruits[name]);
                            }

                            is the same as :

                            const getFruit = (name) => {
                                return new Promise((resolve, reject) => {
                                    const fruits = {
                                        apple: 'ðŸŽ',
                                        banana: 'ðŸŒ',
                                        orange: 'ðŸŠ'
                                    }
                                    resolve(fruits[name]);
                                })
                            }
                        </pre>
                    </li>
                    <li><code>await</code> we can use this keyword to wait for the promise to be settled, so whats happening inside the async function cannot move forward until the promise is settled
                    
                        <pre>
                            const makeSmoothie = async () => {
                                const apple = await getFruit('apple');
                                const banana = await getFruit('banana');
                                const orange = await getFruit('orange');
                                return [apple, banana, orange];
                            }

                            makeSmoothie().then(console.log)
                            //keep in mind we cannot console.log(makeSmoothie()) because youre logging a Promise object, not the returned value that you want. Using then() or await ensures our promise resolves (Response object), at which point it will return the value you want. 


                            which is the same as: 

                            //using Promise syntax
                            const makeSmoothie = () => {
                                return getFruit('apple')
                                    .then(apple => getFruit('banana'))
                                    .then(banana => getFruit('orange'))
                                    .then(orange => {
                                        // Do something with apple, banana, and orange here
                                        return [apple, banana, orange]; // Return the result if needed
                                    })
                                    .catch(error => {
                                        // Handle any errors that occur during the process
                                        console.error("An error occurred:", error);
                                    });
                            };
                        </pre>

                        Although for this example, we don't need to wait on each fruit, we can just wait on the whole smoothie to be made (that means each fruit can be run in parallel, while we wait for the array)

                        const makeSmoothie = async () => {
                            const a = getFruit('apple');
                            const b = getFruit('banana');
                            const c = getFruit('orange');
                            const smoothie = await Promise.all([a, b, c]);
                            return smoothie;
                        }
                        //Promise.all() will wait for all promises in the array to be settled, await is used to stop the execution of the function until the promise settles. 

                        //this will allow use to triple the speed of the function, instead of waiting on each fruit earlier by using 3 awaits.
                    </li>
                    <li>Async / await also provides the ability of error handling: 
                        <pre>
                            const makeSmoothie = async () => {
                                try {
                                    const apple = await getFruit('apple');
                                    const banana = await getFruit('banana');
                                    const orange = await getFruit('orange');
                                    return [apple, banana, orange];
                                } catch (error) {
                                    console.error("An error occurred:", error);
                                }
                            }
                        </pre>
                    </li>
                    <li>One thing to be aware of is that array methods like map or forEach will not pause the function when using await. If you want every promise to be awaited, we must use a traditional for Loop

                        <pre>
                            const makeSmoothie = async () => {
                                const smoothie = [];
                                for (const fruit of fruits) {
                                    smoothie.push(await getFruit(fruit));
                                }
                                return smoothie;
                            }
                        </pre>

                        However if you don't want to await every promise, you can await the for loop instead.

                        <pre>
                            const makeSmoothie = async () => {
                                const smoothie = [];
                                for await (const fruit of fruits) {
                                    smoothie.push(getFruit(fruit));
                                }
                                return smoothie;
                            }
                        </pre>

                        You can also use await on conditionals as well. 
                    </li>
                </ul>
            </fieldset>
            <fieldset id="Modern Javascript for Dinosaurs">
                <legend>Modern Javascript for Dinosaurs</legend>
                <ul>
                    <li style="list-style-type: none">Using Javascript the 'old-school' way</li>
                    <li>You can includes js libraries through the html head. The issue is that these libraries does not update, and the user would need to find and download new version of the libraries every time. You are also creating local variables of the libraries which is not a good work flow.</li>
                    <li>(modern way) Javascript package managers (npm) - used to install and manage libraries; NPM was originally a package manager for node.js, a javascript runtime designed to run on the server, not the frontend. npm is automatically installed with node.</li>
                    <li>You can initialize your folder as a package manager with <code>npm init</code> which creates a package.json file</li>
                    <li><code>npm install {library}</code> - allows you to install a library; You will notice a new folder called node_modules which will download the repositories of the library and link it for you to your project to use. It also will list out all the dependencies / 3rd party libraries you need.</li>
                    <li><code>var {library} = require({library}) / import {library} from {library}</code> this method is used to import a library from the node_modules folder and is placed at the top of your js file. HOWEVER THIS DOES NOT WORK ON FRONTEND JS, it only works on backend js. We must use a module loader / a bundler such as webpack (download: $ npm install webpack webpack-cli --save-dev)</li>
                    <li>The webpack bundler is used to bundle the js files together. We can then use the new bundled js files in our html to run the code. The only issue now is that we must run our code on the terminal for webpack to bundle our js files:
                        <code>./node_modules/.bin/webpack {input file} -o {output file: dist/bundles.js}</code>
                    </li>
                    <li>We must configure our webpack to make bundling our js files easier. We can do this through webpack.config.js

                        <pre>
                            //inside the file
                            module.exports = {
                                entry: 'index.js', //input file
                                output: {
                                    filename: 'bundle.js',
                                    path: path.resolve(__dirname, 'dist') //optional; this places the bundled js file in the dist folder (if not already done so)
                                }
                            }
                        </pre>
                    Using this config file, removes the need to put our input and output files on the terminal. 
                    </li>
                    <li>There are other issues however. If we update our original input file, we must rerun the webpack command on terminal to update our bundled js file. The bundle.js is also hard to debug because its minified and not readable, so we want to still use our original input file to read the code. We can  configure this in webpack.config.js:

                        <pre>
                            //inside the file
                            module.exports = {
                                entry: 'index.js', //input file
                                output: {
                                    filename: 'bundle.js',
                                    path: path.resolve(__dirname, 'dist') //optional; this places the bundled js file in the dist folder (if not already done so)
                                },
                                devtool: 'source-map', //allows us to use our original input file to read the code
                                mode: 'development' //won't minify the bundled js file
                            }
                        </pre>
                    </li>
                    <li>We can also transpire (change the language) the js files using a transpiler like babel and then configured to be used with webpack:
                        <pre>
                            $ npm install @babel/core @babel/preset-env babel-loader --save-dev

                            //3 separate packages as dev dependencies â€” @babel/core is the main part of babel, @babel/preset-env is a preset defining which new JavaScript features to transpile, and babel-loader is a package to enable babel to work with webpack.

                            // webpack.config.js
                            module.exports = {
                            mode: 'development',
                            entry: './index.js',
                            output: {
                                filename: 'main.js',
                                publicPath: 'dist' //only necessary for webpack dev server to work; 
                            },
                            module: {
                                rules: [
                                {
                                    test: /\.js$/,
                                    exclude: /node_modules/,
                                    use: {
                                    loader: 'babel-loader',
                                    options: {
                                        presets: ['@babel/preset-env']
                                    }
                                    }
                                }
                                ]
                            }
                            };

                            //basically what this does is that it tells webpack to look for any js files (not in the node_modules) and user the babel-loader to transpile them with the babel preset (env); **Remember to run your webpack code on the terminal** This will change so our language uses es5 instead of es6. 
                        </pre>
                        Babel helps us ensure we have the latest features in our code for our language. 
                    </li>
                    <li>Using a task runner to automate our tasks, like running webpack code on the terminal. You can configure this on your package.json under the scripts key:

                        <pre>
                            {
                                "name": "modern-javascript-example",
                                "version": "1.0.0",
                                "description": "",
                                "main": "index.js",
                                "scripts": {
                                    "test": "echo \"Error: no test specified\" && exit 1",
                                    "build": "webpack --progress --mode=production", //makes bundled js file minified
                                    "watch": "webpack --progress --watch" //watches for any changes and rebuilds the bundled js file
                                },
                                "author": "",
                                "license": "ISC",
                                "dependencies": {
                                    "moment": "^2.22.2"
                                },
                                "devDependencies": {
                                    "@babel/core": "^7.0.0",
                                    "@babel/preset-env": "^7.0.0",
                                    "babel-loader": "^8.0.2",
                                    "webpack": "^4.17.1",
                                    "webpack-cli": "^3.1.0"
                                }
                            }

                            $ npm run build

                            $ npm run watch
                        </pre>
                    </li>
                    <li>We can finally install webpack dev server, that allows us to run our code on a live server:
                        <pre>
                            $ npm install webpack-dev-server --save-dev //install webpack dev server

                            {
                                "name": "modern-javascript-example",
                                "version": "1.0.0",
                                "description": "",
                                "main": "index.js",
                                "scripts": {
                                    "test": "echo \"Error: no test specified\" && exit 1",
                                    "build": "webpack --progress -p",
                                    "watch": "webpack --progress --watch",
                                    "server": "webpack-dev-server --open" //runs the bundled js file on a live server
                                },
                                "author": "",
                                "license": "ISC",
                                "dependencies": {
                                    "moment": "^2.19.1"
                                },
                                "devDependencies": {
                                    "@babel/core": "^7.0.0",
                                    "@babel/preset-env": "^7.0.0",
                                    "babel-loader": "^8.0.2",
                                    "webpack": "^3.7.1",
                                    "webpack-dev-server": "^3.1.6"
                                }
                            }

                            $ npm run server
                        </pre>
                    </li>
                </ul>
            </fieldset>
            <fieldset id="Node.js Crash Course">
                <legend>Node.js Crash Course</legend>
                <ul>
                    <li>Node.js is a runtime environment for javascript that allows us to build server-side applications. It allows us to create code that can be executed on the server. </li>
                    <li>What is node.js?
                        <ul>
                            <li>A Javascript runtime is not a language or a framework, it is a runtime/running on a machine as a server environment. </li>
                            <li>It is built on the V8 Javascript engine (same as Google Chrome). </li>
                            <li>Written in c++, and essentially allows use to run javascript code on the server. </li>
                            <li>Mostly used for developing server-side and networking apps/apis. </li>
                            <li>It takes the javascript out of the browser.</li>
                            <li>It is fast, scalable, and popular in many areas of the industry. </li>
                        </ul>
                    </li>
                    <li>How does node.js work?
                        <ul>
                            <li>it runs on the V8 javascript engine</li>
                            <li>This V8 javascript engine is responsible for converting javascript code into machine code and executing it. </li>
                            <li>Node takes that engine and make it run on the server side.</li>
                            <li>Node.js is nonblocking, so it doesn't block the rest of the code by using events and callbacks to run asynchronous code.</li>
                            <li>In node.js, there is a single main thread that executes all the code. (thread being the code itself)</li>
                            <li>Node.js uses the event loop to manage asynchronous code. When a request is fulfilled, it triggers a callback and is added to the event loop. The event loop will pick up the callback and run it.</li>
                        </ul>
                    </li>
                    <li>What is Node.js used for?
                        <ul>
                            <li>used for developing APIs / server rendered apps</li>
                            <li>Real-time applications like chat or multiplayer game apps</li>
                            <li>Microservices - independent components that communicate with each other</li>
                            <li>Command Line Tools like CLI command line interfaces </li>
                            <li>Bots to automate tasks like twitter, slack, and discord</li>
                            <li>Web Scraping - web scraping is the process of extracting data from websites</li>
                            <li>Web Servers - sophisticated web servers, handling complex routing, serving dynamic content, or a simple static file server</li>
                            <li>Node.js is not good for CPU-intensive tasks like computations (better using server-side languages) </li>
                        </ul>
                    </li>
                    <li>Installation
                        <ul>
                            <li>Go to nodejs.org/en and download</li>
                            <li>go to terminal and check the versions of node and npm with commands <code>node -v</code> and <code>npm -v</code></li>
                        </ul>
                    </li>
                    <li>Node Repl
                        <ul>
                            <li>REPL - Read Eval Print Loop</li>
                            <li>REPL is a way to run javascript code in the terminal</li>
                            <li>You can start the REPL with the command <code>node</code> on your terminal and its a great way to test out your code</li>
                            <li>You can leave with the key short ctrl c</li>
                        </ul>
                    </li>
                    <li>Initialize a node.js project
                        <ul>
                            <li><code>npm init</code> - creates a package.json</li>
                            <li>It will ask you a lot of questions to build the json file</li>
                        </ul>
                    </li>
                    <li>Running js files on the server with node.js 
                        <ul>
                            <li><code>node {filename}</code> - command runs the js file</li>
                            <li>Keep in mind Window, Document, and Node object is not available on the server side, since that is on the browser. There is no DOM </li>
                            <li>There is a process object, pertaining to the current process that is running</li>
                        </ul>
                    </li>
                    <li>Common JS Modules - for exporting and importing to other js files
                        <ul>
                            <li>common js - native node js module libraries. 
                                <ul>
                                    <li>To default export a module we use <code>module.exports = {function}</code></li>
                                    <li>To export multiple functions we use <code>module.exports = {function1, function2}</code></li>
                                    <li>To import a module we use <code>var function = require({filename})</code></li>
                                    <li>To import multiple functions we use <code>var {function1, function2} = require({filename})</code></li>
                                </ul>
                            </li>
                            <li>es6 modules 
                                <ul>
                                    <li>Make sure you add in the type key in the package.json with the value of "module" to enable es6</li>
                                    <li>To export a module(s) we use <code>export default function</code> or <code>export (default) {function1, function2}</code> to place at the end of the file or directly from the function itself with <code>export {function}()...</code></li>
                                    <li>To import a module we use <code>import {function} from {filename.js}</code></li>
                                    <li>You can also import two different modules: one from default and one from named with <code>import function, {function1, function2} from {filename.js}</code></li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>HTTP Module and creating a server
                        <ul>
                            <li>HTTP module is included with node js and we can import it with es6 <code>import http from 'http';</code></li>
                            <li><code>const server = http.createServer((req, res) => {})</code> - creates a server</li>
                            <li>Inside the response we can use <code>res.write()</code> and <code>res.end()</code> to write a response to the client and end the response / stream. We can also omit the res.write() and place the response directly in the res.end(). We can also place our json code directly in the res.end()</li>
                            <li><code>server.listen(port, () => {})</code> - listens to the port</li>
                            <li>To run your server we use <code>node server (or whatever variable you set it to when creating the server)</code></li>
                            <p>With these steps, we just created our own server from localhost!! </p>
                            <li><code>res.setHeader()</code> - sets the headers for our response.</li>
                            <li><code>res.statusCode</code> - sets the status code</li>
                            <li><code>res.writeHead(statusCode, headers)</code> - shorthand; sets the status code and headers</li>
                            <pre>
                                import http from 'http';

                                const server = http.createServer((req, res) => {
                                    res.setHeader('Content-Type', 'text/plain');
                                    res.statusCode = 404;
                                    res.end('Hello World')
                                })

                                server.listen(8000, () => console.log('running on port 8000'))

                                //on the terminal
                                $ node server // runs the server
                            </pre>
                        </ul>
                    </li>
                    <li>NPM scripts - allows you to run commands on the server
                        <pre>
                            //inside the package.json
                            "scripts":{
                                "start": "node server.js"
                            }
                        </pre>
                        This example can run the server on the terminal with <code>$ npm start</code> or if the key is not start it can be <code>$ npm run {key}</code>. Although it might seem the same as node server.js, npm scripts can provide abstraction for running commands on the server. You can add flags, environmental variables, and allow tools like nodemon to automatically reload your server upon changes. 
                    </li>
                    <li>Nodemon
                        <ul>
                            <li><code>npm install/i -g nodemon</code> - install nodemon (reminder that the g flag is for global; as in a global restart)</li>
                            <li>We can also do the <code>-D</code> flag to install as a dev dependency. This will create a node_module folder if you didn't have one yet, it will also add in nodemon as a dev dependency on the package.json. And finally the package-lock.json which includes the dev dependency tree with all the versions of the packages</li>
                            <li><code>nodemon server.js</code> - when we run the server, with nodemon we can restart the server on changes without restarting the server. You can also place this in the npm script. </li>
                        </ul>
                    </li>
                    <li>Gitignore
                        <ul>
                            <li>When pushing to github, you never want to show the node_modules folder because users can recreate it. So we can ignore the node_modules folder with <code>.gitignore</code> file and place the folder in the .gitignore</li>
                        </ul>
                    </li>
                    <li>Environment Variables - variables in your environment on your system that you can access from your program and programming languages that can be used in your code
                        <ul>
                            <li>we can create an <code>.env</code> - file that contains environment variables (you should also add this file to your .gitignore)
                                <pre>
                                    //in .env file
                                    PORT=8000 //for example adding in a port
                                </pre>
                            We then must update the start script to include the .env file.
                                <pre>
                                    //in package.json
                                    "start": "nodemon --env-file = .env server.js"

                                    //in our server.js
                                    const port = process.env.PORT || 8000;
                                    server.listen(port, () => console.log(`running on port ${port}`))
                                </pre>
                            </li>
                        </ul>
                    </li>
                    <li>Request Object
                        <ul>
                            <li><code>res.url()</code> - returns the url of the request</li>
                            <li><code>res.method()</code> - returns the method of the request</li>
                        </ul>
                    </li>
                    <li>Marking Requests from Postman - You can test requests and responses in Postman (there is also a helpful extension on vscode)</li>
                    <li>Creating Routers 
                        <pre>
                            //in server.js
                            const server = http.createServer((req, res) => {
                                try{
                                    //check for GET request
                                    if(req.method === 'GET'){
                                        if(req.url === '/'){
                                            res.writeHead(200, {'Content-Type': 'text/html'})
                                            res.end('Hello World')
                                        }else if (req.url === '/about'){
                                            res.writeHead(200, {'Content-Type': 'text/html'})
                                            res.end('About Page')
                                        }else{
                                            res.writeHead(404, {'Content-Type': 'text/html'})
                                            res.end('Not Found')
                                        }
                                    }
                                    else{
                                        throw new Error('Method not allowed');
                                    }
                                } catch (error){
                                    res.writeHead(500, {'Content-Type': 'text/plain'})
                                    res.end('Server Error')
                                }
                                
                            })
                        </pre>
                    </li>
                    <li>Loading files
                        <ul>
                            <li>We can use the <code>fs</code> module to load files</li>
                            <li>There are many ways to use the fs module like: asynchronous callback, synchronous callback, promises</li>
                            <li>We will use the promise version: <code>import fs from 'fs/promises'</code></li>
                            <li>Next we need the url paths to load the files
                                <ul>
                                    <li>Through common.js we can use <code>__filename</code> - gives current file name with the path and <code>__dirname</code> - current directory you're in (however these are not available with es modules; only on common js)</li>
                                    <li>We must use instead the url and path module for es modules: <code>import url from 'url'</code> to create our own urls and <code>import path from 'path'</code> to create our own paths
                                        <pre>
                                            //in server.js
                                            const __filename  = url.fileURLToPath(import.meta.url);
                                            const __dirname = path.dirname(__filename)

                                            console.log(__filename, __dirname)
                                            //output: C:\Users\BattleStation\Desktop\Website Project\100Devs\server.js C:\Users\BattleStation\Desktop\Website Project\100Devs
                                        </pre>
                                        <ul>
                                            <li><code>url.fileURLToPath({url})</code> - converts a url to a path</li>
                                            <li><code>path.dirname({path})</code> - returns the directory name of a path</li>
                                        </ul>
                                        
                                    </li>
                                </ul>
                            </li>
                            <li>Now that we have our urls and paths we can load our files according to our url on the request. 

                                <pre>
                                    //in server.js
                                    const server = http.createServer(async (req, res) => {
                                        try{
                                            //check for GET request
                                            if(req.method === 'GET'){
                                                let filePath;
                                                if(req.url === '/'){
                                                    filePath = path.join(__dirname, 'public', 'index.html')
                                                }else if (req.url === '/about'){
                                                    filePath = path.join(__dirname, 'public', 'about.html')
                                                }else{
                                                    throw new Error('File not found')
                                                }

                                                const data = await fs.readFile(filePath, 'utf-8')

                                                res.setHeader('Content-Type', 'text/html') //set the content type
                                                res.write(data) //write the data to the response
                                                res.end() //end the response
                                            }
                                            else{
                                                throw new Error('Method not allowed');
                                            }
                                        } catch (error){
                                            res.writeHead(500, {'Content-Type': 'text/plain'})
                                            res.end('Server Error')
                                        }
                                    })
                                </pre>

                                Using the path module we can do <code>path.join()</code> - joins two or more path segments together
                            </li>
                        </ul>
                    </li>
                    <li>Building a simple API
                        <ul>
                            <li>We can import the createServer method from the http module</li>
                            <pre>
                                //in server.js
                                import {createServer} from 'http'; 
                                const PORT = process.env.PORT;
                                const users = [
                                    {id: 1, name: 'John'},
                                    {id: 2, name: 'Jane'},
                                    {id: 3, name: 'Jim'}
                                ]

                                const server = createServer((req, res) => {
                                    if(req.url === '/api/users' && req.method === 'GET'){
                                        res.setHeader('Content-Type', 'application/json');
                                        res.write(JSON.stringify(users)); //(res.json({}))
                                        res.end();
                                    }
                                    else if(req.url.match(/\/api\/users\/([0-9]+)/) && req.method === 'GET'){ 
                                        //match any number after users
                                        
                                        const id = req.url.split('/')[3]; //or grab the id from the matched results array

                                        const user = users.find(u => u.id === Number(id));
                                        res.setHeader('Content-Type', 'application/json');
                                        if(user){
                                            res.write(JSON.stringify(user)); //(res.json({}))
                                        }
                                        else{
                                            res.statusCode = 404;
                                            res.write(JSON.stringify({message: 'User Not found'})); 
                                        }
                                        res.end();
                                    }
                                    else{
                                        res.setHeader('Content-Type', 'application/json');
                                        res.statusCode = 404;
                                        res.write(JSON.stringify({message: 'Not found'}));
                                        res.end();
                                    }
                                })

                                server.listen(PORT, () => console.log(`running on port ${PORT}`))
                            </pre>
                        </ul>
                    </li>
                    <li>Middleware - modules / functions that sit between requests and responses to allow you to add functionality to your server.
                        <pre>
                            //logger Middleware; same syntax with node.js or express
                            const logger = (req, res, next) => {
                                console.log(`${req.method} ${req.url}`)
                                next() // move on to the next middleware
                            }

                            //JSON Middleware
                            const jsonMiddlewarre = (req, res, next) => {
                                res.setHeader('Content-Type', 'application/json');
                                next();
                            }

                            //Route handler for GET /api/users
                            const getUsersHandler = (req, res) => {
                                res.write(JSON.stringify(users))
                                res.end()
                            }

                            //Route handler for GET /api/users/:id
                            const getUserByIdHandler = (req, res) => {
                                const id = req.url.split('/')[3];
                                const user = users.find(u => u.id === Number(id));
                                
                                if(user){
                                    res.write(JSON.stringify(user)); //(res.json({}))
                                }
                                else{
                                    res.statusCode = 404;
                                    res.write(JSON.stringify({message: 'User Not found'}));
                                }
                                res.end();
                            }

                            //Not found handler
                            const notFoundHandler = (req, res) => {
                                res.statusCode = 404;
                                res.write(JSON.stringify({message: 'Not found'}));
                                res.end();
                            }
                            const server = createServer((req, res) => {
                                logger(req, res, () => {
                                    jsonMiddlewarre(req, res, () => {
                                        if(req.url === '/api/users' && req.method === 'GET'){
                                            getUsersHandler(req, res)
                                        }
                                        else if(req.url.match(/\/api\/users\/([0-9]+)/) && req.method === 'GET'){
                                            getUserByIdHandler(req, res)
                                        }
                                        else{
                                            notFoundHandler(req, res)
                                        }
                                    })
                                })
                            
                            })
                            server.listen(PORT, () => console.log(`running on port ${PORT}`))

                            
                        </pre>
                       You will notice that we can console whats happening inside the logger / middleware and then we can move on to the rest of our code through the next middleware
                    </li>
                    <li>Get Request Body for POST
                        <ul>
                            <li><code>req.on('', () => {})</code> - listen for data </li>
                            <pre>
                                //Route handler for POST /api/users
                                const createUserHandler = (req, res) => {
                                    let body = '';

                                    //listen for data
                                    req.on('data', (data) => {
                                        body += data.toString();
                                    })

                                    //listen when the request ends
                                    req.on('end', () => {
                                        const user = JSON.parse(body); //parse the body as JSON
                                        users.push(user); //add the user to the users array
                                        res.statusCode = 201; //create a new user
                                        res.write(JSON.stringify(user)); //return the new user
                                        res.end(); //end the response
                                    })
                                }

                                const server = createServer((req, res) => {
                                    logger(req, res, () => {
                                        jsonMiddlewarre(req, res, () => {
                                            if(req.url === '/api/users' && req.method === 'GET'){
                                                getUsersHandler(req, res)
                                            }
                                            else if(req.url.match(/\/api\/users\/([0-9]+)/) && req.method === 'GET'){
                                                getUserByIdHandler(req, res)
                                            }
                                            else if (req.url === '/api/users' && req.method === 'POST'){
                                                createUserHandler(req, res)
                                            }
                                            else{
                                                notFoundHandler(req, res)
                                            }
                                        })
                                    })
                                
                                })
                            </pre>
                        </ul>
                    </li>
                    <li>File System Module
                        <ul>
                            <li><code>fs</code> - file system module</li>
                            <li><code>fs.readFile()</code> - read a file</li>
                            <li><code>fs.writeFile()</code> - write a file</li>
                            <li><code>fs.appendFile()</code> - append to a file</li>
                            <li><code>fs.unlink()</code> - delete a file</li>

                            <pre>
                                //import fs from 'fs'; //import the fs module
                                import fs from 'fs/promises'; //promise version

                                // readFile() - callback version

                                fs.readFile('./file.txt', 'utf8',(err, data) => {
                                    if (err) throw err;
                                    console.log(data);
                                })

                                // readFileSync() - synchronous version
                                const data = fs.readFileSync('./file.txt', 'utf8');
                                console.log(data);

                                // readFile() - promise version
                                fs.readFile('./file.txt', 'utf8')
                                    .then(data => console.log(data))
                                    .catch(err => console.log(err));

                                // readFile() - async/await version
                                const readFile = async () => {
                                    try {
                                        const data = await fs.readFile('./file.txt', 'utf8');
                                        console.log(data);
                                    } catch(err) {
                                        console.log(err);
                                    }
                                }

                                

                                //4 different ways to write to a file

                                //writeFile() - await/async version
                                const writeFile = async () => {
                                    try {
                                        await fs.writeFile('./file.txt', 'Hello World!');
                                        console.log('File written to disk');
                                    } catch(err) {
                                        console.log(err);
                                    }
                                }
                                
                                //appendFile() -  await/async version
                                const appendFile = async () => {
                                    try {
                                        await fs.appendFile('./file.txt', '\nThis is appended text');
                                        console.log('File appended to disk');
                                    } catch(err) {
                                        console.log(err);
                                    }
                                }

                                writeFile(); // write to the file
                                appendFile(); //append/add to the file
                                readFile();  //read from the file
                            </pre>
                        </ul>
                    </li>
                    <li>Path Module - for working with file paths
                        <ul>
                            <li><code>path.basename({filepath})</code> - returns the last portion of a path</li>
                            <li><code>path.dirname({filepath})</code> - returns the directory name of a path</li>
                            <li><code>path.extname({filepath})</code> - returns the extension of a path</li>
                            <li><code>path.parse({filepath})</code> - returns an object containing all the path properties</li>
                            <li><code>path.join({path1}, {path2})</code> - joins two or more paths; this method is useful because different os have different path separators/delimiters</li>
                            <li><code>path.resolve({path1}, {path2})</code> - resolves a sequence of paths or path segments</li>

                            <pre>
                                import path from 'path';
                                import url from 'url';
    
                                const filePath = './dir1/dir2/test.txt'
    
                                console.log(path.basename(filePath)); //test.txt
                                console.log(path.dirname(filePath)); //./dir1/dir2
                                console.log(path.extname(filePath)); //.txt
                                console.log(path.parse(filePath)); 
                                //  { 
                                        root: '', 
                                        dir: './dir1/dir2', 
                                        base: 'test.txt', 
                                        ext: '.txt', 
                                        name: 'test' 
                                    }

                                
                                const __filename = url.fileURLToPath(import.meta.url); //current file path; grabbed from the import.meta.url which is the url of the current file youre in. Import meta provides metadata about the current module.

                                const __dirname = path.dirname(__filename); //current directory path

                                console.log(__filename, __dirname) //output: C:\Users\BattleStation\Desktop\Website Project\100Devs\server.js C:\Users\BattleStation\Desktop\Website Project\100Devs

                                const filePath2 = path.join(__dirname, 'dir1', 'dir2', 'test.txt'); //output: C:\Users\BattleStation\Desktop\Website Project\100Devs\dir1\dir2\test.txt

                                const filePath3 = path.resolve(__dirname, 'dir1', 'dir2', 'test.txt'); //output: C:\Users\BattleStation\Desktop\Website Project\100Devs\dir1\dir2\test.txt
                            </pre>
                        </ul>
                    </li>
                    <li>OS Module - for working with operating systems
                        <ul>
                            <li><code>os.userInfo()</code> - returns information about the current user</li>
                            <li><code>os.totalmem()</code> - returns the total amount of memory in the system (in bytes)</li>
                            <li><code>os.freemem()</code> - returns the free memory in the system (in bytes)</li>
                            <li><code>os.cpus()</code> - returns an array of objects containing information about the cpus</li>
                            <li><code>os.platform()</code> - returns the operating system platform</li>
                            <li><code>os.arch()</code> - returns the operating system architecture</li>

                        </ul>
                        <pre>
                            import os from 'os';
                            console.log(os.userInfo()); 
                            console.log(os.totalmem());
                            console.log(os.freemem());
                            console.log(os.cpus());

                            console.log(os.platform(), os.arch());
                        </pre>
                    </li>
                    <li>URL Module - for working with urls
                        <ul>
                            <li><code>new URL({url})</code> - creates a url object</li>
                            
                            <li><code>import.meta.url</code> - returns the url of the current file</li>

                            <li><code>url.parse({url})</code> - parses a url into an object</li>
                            <li><code>url.format({url})</code> - formats an object into a url</li>
                            <li><code>url.fileURLToPath({url})</code> - converts a url to a path</li>
                            <li><code>url.pathToFileURL({path})</code> - converts a path to a url</li>

                            <li><code>url.format({url})</code> - formats an object into a url</li>

                            <li><code> new URLSearchParams({url})</code> - creates a url search params object</li>
                            <li><code>urlsearchparams.get({key})</code> - returns the value of the key</li>
                            <li><code>urlsearchparams.set({key}, {value})</code> - sets the value of the key</li>
                            <li><code>urlsearchparams.delete({key})</code> - deletes the value of the key</li>

                        </ul>
                        <pre>
                            import url from 'url';

                            const urlString = 'https://www.google.com/search?q=hello+world';

                            const urlObj = new URL(urlString);

                            console.log(urlObj); 
                            // 
                            URL {
                                href: 'https://www.google.com/search?q=hello+world',
                                origin: 'https://www.google.com',
                                protocol: 'https:',
                                username: '',
                                password: '',
                                host: 'www.google.com',
                                hostname: 'www.google.com',
                                port: '',
                                pathname: '/search',
                                search: '?q=hello+world',
                                searchParams: URLSearchParams { 'q' => 'hello world' },
                                hash: ''
                            }

                            console.log(url.format(urlObj));
                            // https://www.google.com/search?q=hello+world

                            console.log(import.meta.url); - file URL
                            // C:\Users\BattleStation\Desktop\Website Project\100Devs\server.js

                            console.log(url.fileURLToPath(import.meta.url));
                            // \Users\BattleStation\Desktop\Website Project\100Devs\server.js

                            const params = new URLSearchParams(urlObj.search);
                            console.log(params); 
                            // URLSearchParams { 'q' => 'hello world' }

                            console.log(params.get('q'));
                            // hello world

                            params.set('limit', '5');
                            console.log(params);
                            // URLSearchParams { 'q' => 'hello world', 'limit' => '5' }

                            params.delete('limit');
                            console.log(params);
                            // URLSearchParams { 'q' => 'hello world' }
                        </pre>
                    </li>
                    <li>Crypto Module - for working with cryptographic functions
                        <ul>
                            <li><code>crypto.createHash({algorithm})</code> - creates a hash object</li>
                            <li><code>hash.update({data})</code> - updates the hash with the data</li>
                            <li><code>hash.digest({format})</code> - returns the hash in the specified format</li>

                            <li><code>crypto.randomBytes({size})</code> - returns a buffer of random bytes</li>

                            <li><code>crypto.createCipheriv({algorithm}, {key}, {iv})</code> - creates a cipher object</li>
                            <li><code>cipher.update({data})</code> - updates the cipher with the data</li>
                            <li><code>cipher.final({format})</code> - returns the cipher in the specified format</li>

                            <li><code>crypto.createDecipheriv({algorithm}, {key}, {iv})</code> - creates a decipher object</li>
                            <li><code>decipher.update({data})</code> - updates the decipher with the data</li>
                            <li><code>decipher.final({format})</code> - returns the decipher in the specified format</li>

                        </ul>
                        <pre>
                            import crypto from 'crypto';

                            const hash = crypto.createHash('sha256')
                            hash.update('password1234');
                            console.log(hash.digest('hex')); 
                            // 5f4dcc3b5aa765d61d8327deb882cf99
                            ----------------------------------------------------
                            crypto.randomBytes(16, (err, buffer) => {
                                if (err) throw err;
                                console.log(buffer.toString('hex'));
                            }) or 
                            crypto.randomBytes(16).toString('hex');
                            // 5f4dcc3b5aa765d61d8327deb882cf99
                            // this is useful for someone like randomly generating user ids or passwords
                            ----------------------------------------------------
                            const algorithm = 'aes-256-ctr';
                            const key = crypto.randomBytes(32);
                            const iv = crypto.randomBytes(16);

                            const cipher = crypto.createCipheriv(algorithm, key, iv);
                            let encrypted = cipher.update('Hello, this is a secret message', 'utf8', 'hex');
                            encrypted += cipher.final('hex');
                            console.log(encrypted);
                            // we encrypt our cipher text from the update method

                            const decipher = crypto.createDecipheriv(algorithm, key, iv);
                            let decrypted = decipher.update(encrypted, 'hex', 'utf8');
                            decrypted += decipher.final('utf8');
                            console.log(decrypted);
                            // we decrypt our cipher text from the update method
                        </pre>
                    </li>
                    <li>Events Module - for working with events and Event Emitters / Listeners
                        <ul>
                            <li><code>new EventEmitter()</code> - creates an event emitter</li>
                            <li><code>emitter.on({event}, {callback})</code> - registers an event listener</li>
                            <li><code>emitter.emit({event})</code> - emits / triggers an event</li>


                        </ul>
                        <pre>
                            import { EventEmitter } from 'events';

                            const emitter = new EventEmitter();

                            function greetHandler(name){
                                console.log('hello' + name);
                            }

                            function goodbyeHandler(name){
                                console.log('goodbye' + name);
                            }

                            //Register Event Listeners
                            emitter.on('greet', greetHandler);
                            emitter.on('goodbye', goodbyeHandler);

                            //emit events
                            emitter.emit('greet', "John"); //Output: hello John
                            emitter.emit('goodbye', "John"); //Output: goodbye John

                            //Error Handling with error Event Listener
                            emitter.on('error', (error) => {
                                console.error('An error occurred:', error);
                            });

                            //Simulate Error Handling with event listener is triggered 
                            emitter.emit('error', new Error('Something went wrong'));
                            //An error occurred: Error: Something went wrong
                        </pre>
                    </li>
                    <li>Process Object
                        <ul>
                            <li>The process object is a global object that contains information about the current Node.js process.</li>

                            <li><code>process.argv</code> - an array of the process's command line arguments</li>
                            <li><code>process.env</code> - an object containing the process's environment variables</li>
                            <li><code>process.pid</code> - the process ID</li>
                            <li><code>process.cwd()</code> - the current working directory</li>)
                            <li><code>process.title</code> - the process title</li>
                            <li><code>process.memoryUsage()</code> - the process memory usage</li>
                            <li><code>process.uptime()</code> - the process uptime</li>
                            <li><code>process.exit({#})</code> - exits the process; the number 0 is the success exit code, and the number 1 is the failure exit code</li>
                            <li><code>process.on({event}, {callback})</code> - registers an event listener</li>
                            <li>command - <code>node processDemo.js {command}</code> - adds the command to the process's argv array </li>
                        </ul>
                        <pre>
                            console.log(process); //prints out the process object

                            console.log(process.argv); //prints out the process's argv array

                            console.log(process.argv[3]); //prints out the 3rd item in the argv array

                            console.log(process.env.LOGNAME); //prints out the LOGNAME environment variable

                            console.log(process.pid); //prints out the process ID

                            console.log(process.cwd()); //prints out the current working directory

                            console.log(process.title); //prints out the process title

                            console.log(process.memoryUsage()); //prints out the process memory usage

                            console.log(process.uptime()); //prints out the process uptime

                            //event listener for exit
                            process.on('exit', (code) => {
                                console.log(`About to exit with code: ${code}`);
                            });  //output: About to exit with code: 0
                            

                            process.exit(0); //exits the process

                            console.log('Hello from after exit'); //this statement will not be executed because the process has exited
                        </pre>
                    </li>
                </ul>
            </fieldset>
            <fieldset id = "Javascript.info - Async / Await">
                <legend>Javascript.info - Async / Await</legend>
                <ul>
                    <li>Callbacks
                        <ul>
                            <li>Besides setTimeout method, loading scripts and modules are also asynchronous.</li>
                            <li>Callbacks are functions that are passed as an argument to another function</li>
                            <li>When calling a function inside a loadScript function, we have to use a callback function with <code>script.onload</code> - when the script is loaded, to then call the callback function at the right time.
                                <pre>
                                    function loadScript(src, callback) {
                                        let script = document.createElement('script');
                                        script.src = src;
                    
                                        script.onload = () => callback(script);
                    
                                        document.head.append(script);
                                    }
                                    loadScript('/my/script.js', () => newFunction());
                                    //newFunction will be called once the script is loaded
                                </pre>
                            This is known as 'callback-based' style of asynchronous programming.
                            </li>
                            <li>To load two scripts sequentially, we can nest callbacks known as 'callback hell' or 'pyramid of doom'</li>
                            <li>A way to manage this is by making all the functions a top level function. However, this lacks organization and readability.
                                <pre>
                                    loadScript('1.js', step1);
                                    function step1(error, script) {
                                    if (error) {
                                            handleError(error);
                                        } else {
                                            // ...
                                            loadScript('2.js', step2);
                                        }
                                    }
                                    function step2(error, script) {
                                        if (error) {
                                            handleError(error);
                                        } else {
                                            // ...
                                            loadScript('3.js', step3);
                                        }
                                    }
                                    function step3(error, script) {
                                        if (error) {
                                            handleError(error);
                                        } else {
                                            // ...continue after all scripts are loaded (*)
                                        }
                                    }
                                </pre>
                            </li>
                        </ul>
                    </li>
                    <li>Promises
                        <ul>
                            <li><code>new Promise(resolve, reject)</code> - we can create our own promises through the constructor. Resolve and reject are callbacks provided by Javascript itself. </li>
                            <li><code>resolve(value)</code> - the promise is resolved</li>
                            <li><code>reject(error)</code> - the promise is rejected</li>
                            <li>There are properties in the promise object:
                                <ul>
                                    <li><code>state</code> - the state of the promise; it starts from 'pending' to 'resolved' or 'rejected'</li>
                                    <li><code>result</code> - the result of the promise; it starts from 'undefined' to 'value' or 'error'</li>
                                </ul>
                                However these properties are not accessible. You can only call <code>then</code> and <code>catch</code> instead.
                            </li>
                            <li>There can only be one single result or error, so you can only call either resolve or reject.</li>
                            <li><code>promise.then(resolve)</code> - indicates the promise is resolved; then method will use the resolve callback to resolve the promise</li>
                            <li><code>promise.catch(reject)</code> - indicates the promise is rejected; then method will use the reject callback to reject the promise
                    
                                <pre>
                                    let promise = new Promise((resolve, reject) => {
                                        setTimeout(() => reject(new Error("Whoops!")), 1000);
                                      });
                    
                                      // .catch(f) is the same as promise.then(null, f)
                                      promise.catch(alert); // shows "Error: Whoops!" after 1 second
                    
                                </pre>
                            </li>
                            <li><code>promise.finally()</code> - indicates the promise is fulfilled (resolved or rejected); It does not accept any parameters, but you can chain it with other methods like .then or .catch. We use finally() when we want to do something regardless of the promise result.</li>
                            <li>The difference between resolve and reject, and .then and .catch is that resolve and reject is used to set the state of the promise while .then and .catch is used to set the result/ or what you want to happen of the promise. One is used to construct a promise, and the other is used to consume/interact with the promise.</li>
                            <li>Using then and catch is much more preferred, because callback hell is difficult to read and maintain.
                                <pre>
                                    //callback based
                                    function loadScript(src, callback) {
                                        let script = document.createElement('script');
                                        script.src = src;
                    
                                        script.onload = () => callback(null, script);
                                        script.onerror = () => callback(new Error(`Script load error for ${src}`));
                    
                                        document.head.append(script);
                                    }
                                    //promise based
                                    function loadScript(src) {
                                        return new Promise(function(resolve, reject) {
                                          let script = document.createElement('script');
                                          script.src = src;
                    
                                          script.onload = () => resolve(script);
                                          script.onerror = () => reject(new Error(`Script load error for ${src}`));
                    
                                          document.head.append(script);
                                        });
                                    }
                                </pre>
                                Promises allows us to do things in natural order, we run the promise first, then() will write what to do next with the result. We can also call then() multiple times.
                                Callbacks must know what to do with the result before we call them. And there can only be one callback.
                            </li>
                        </ul>
                    </li>
                    <li>Promises Chaining
                        <ul>
                            <li>Since then and catch are capable of chaining together because they themselves return promises, we can pass the result through them. The results become additive through the chaining process, so it is very different from separate instance of then() and catch().
                                <pre>
                                    new Promise(function(resolve, reject) {
                                        setTimeout(() => resolve(1), 1000); // (*)
                    
                                    }).then(function(result) { // (**)
                    
                                        alert(result); // 1
                                        return result * 2;
                    
                                    }).then(function(result) { // (***)
                    
                                        alert(result); // 2
                                        return result * 2;
                    
                                    }).then(function(result) {
                    
                                        alert(result); // 4
                                        return result * 2;
                    
                                    });
                    
                                    Here the flow is:
                                    The initial promise resolves in 1 second (*),
                                    Then the .then handler is called (**), which in turn creates a new promise (resolved with 2 value).
                                    The next then (***) gets the result of the previous one, processes it (doubles) and passes it to the next handler.
                                    â€¦and so on.
                                </pre>
                                Should any then() create a return a promise of their own, any further then() handlers will wait for that promise to settle.
                            </li>
                            <li>In frontend programming, promises are often used for network requests using the fetch method, which returns a promise from the server response. The promise resolves with a response object when the remote server responses with headers, but before the full response has been received.</li>
                            <li>When we chain then() together, whats returned each time is the resolved value of the previous promise. However what about the cases where the resolved value can't be returned? We must create a new promise to resolve/return the value we want to pass on to the next then() handler, and thereby extending the promise chain.
                                <pre>
                                    // Make a request for user.json
                                    fetch('/article/promise-chaining/user.json')
                                      // Load it as json
                                      .then(response => response.json())
                                      // Make a request to GitHub
                                      .then(user => fetch(`https://api.github.com/users/${user.name}`))
                                      // Load the response as json
                                      .then(response => response.json())
                                      // Show the avatar image (githubUser.avatar_url) for 3 seconds (maybe animate it)
                                      .then(githubUser => {
                                        let img = document.createElement('img');
                                        img.src = githubUser.avatar_url;
                                        img.className = "promise-avatar-example";
                                        document.body.append(img);
                    
                                        setTimeout(() => img.remove(), 3000); // if we try another then() after this, it will not work and return undefined
                                      });
                    
                                    //adding a new promise instead
                                    fetch('/article/promise-chaining/user.json')
                                    .then(response => response.json())
                                    .then(user => fetch(`https://api.github.com/users/${user.name}`))
                                    .then(response => response.json())
                                    .then(githubUser => new Promise(function(resolve, reject) { // (*)
                                      let img = document.createElement('img');
                                      img.src = githubUser.avatar_url;
                                      img.className = "promise-avatar-example";
                                      document.body.append(img);
                    
                                      setTimeout(() => {
                                        img.remove();
                                        resolve(githubUser); //since we resolve here, it will be added to the promise chain for the next then handler
                                      }, 3000);
                                    }))
                                    // triggers after 3 seconds
                                    .then(githubUser => alert(`Finished showing ${githubUser.name}`));
                                </pre>
                            </li>
                            <li>At the end of the day, we should be refactoring our code to make it more readable and reusable.
                                <pre>
                                    function loadJson(url) {
                                        return fetch(url)
                                          .then(response => response.json());
                                      }
                    
                                      function loadGithubUser(name) {
                                        return loadJson(`https://api.github.com/users/${name}`);
                                      }
                    
                                      function showAvatar(githubUser) {
                                        return new Promise(function(resolve, reject) {
                                          let img = document.createElement('img');
                                          img.src = githubUser.avatar_url;
                                          img.className = "promise-avatar-example";
                                          document.body.append(img);
                    
                                          setTimeout(() => {
                                            img.remove();
                                            resolve(githubUser);
                                          }, 3000);
                                        });
                                      }
                    
                                      // Use them:
                                      loadJson('/article/promise-chaining/user.json')
                                        .then(user => loadGithubUser(user.name))
                                        .then(showAvatar)
                                        .then(githubUser => alert(`Finished showing ${githubUser.name}`));
                                        // ...
                                </pre>
                            </li>
                        </ul>
                    </li>
                    <li>Error Handling with Promises
                        <ul>
                            <li>Whenever a promise rejects, its jumps to the closest rejection handler (catch). So even if you have multiple then handlers, the catch will trigger if any of them fail in the chain of promises.</li>
                            <li>Promise implicitly have a try catch block in it
                                <pre>
                                    new Promise((resolve, reject) => {
                                        throw new Error("Whoops!");
                                    }).catch(alert); // Error: Whoops!
                                    //exactly the same thing...
                                    new Promise((resolve, reject) => {
                                        reject(new Error("Whoops!"));
                                    }).catch(alert); // Error: Whoops!
                                </pre>
                                The try catch automatically catches the error and turns it into a rejected promise. This also works if you throw an error / or any programming error in a promise that is resolved already, it will jump to the catch block afterwards.
                                <pre>
                                    new Promise((resolve, reject) => {
                                        resolve("ok");
                                      }).then((result) => {
                                        blabla(); // no such function
                                      }).catch(alert); // ReferenceError: blabla is not defined
                                </pre>
                            </li>
                            <li>We can also rethrow errors if the first error is not handled, the then handler will be skipped (if applicable) and it will jump the other closest catch handler</li>
                            <li>If there is an unhandled rejection of a promise, then the global error handler will be called through the window's unhandledrejection event handler. Other non-browser environments like node.js will not trigger this event but it will be able to track unhandled errors.
                                <pre>
                                    window.addEventListener('unhandledrejection', function(event) {
                                        // the event object has two special properties:
                                        alert(event.promise); // [object Promise] - the promise that generated the error
                                        alert(event.reason); // Error: Whoops! - the unhandled error object
                                      });
                    
                                      new Promise(function() {
                                        throw new Error("Whoops!");
                                      }); // no catch to handle the error
                                </pre>
                            </li>
                        </ul>
                    </li>
                    <li>Promise API
                        <ul>
                            <li>There are 6 methods from the Promise class.</li>
                            <li><code>Promise.all([promises])</code> - returns an array of promises that is fulfilled when all of the promises in the array are fulfilled. If any of the promises in the array are rejected, the returned promise is immediately rejected. This method is useful to execute multiple promises at the same time.
                                <pre>
                                    Promise.all([
                                        new Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1
                                        new Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2
                                        new Promise(resolve => setTimeout(() => resolve(3), 1000))  // 3
                                    ]).then(alert); // 1,2,3 when promises are ready: each promise contributes an array member
                                </pre>
                                You can also wrap an array of promises into Promise.all().
                                <pre>
                                    let urls = [
                                        'https://api.github.com/users/iliakan',
                                        'https://api.github.com/users/remy',
                                        'https://api.github.com/users/jeresig'
                                    ];
                    
                                    // map every url to the promise of the fetch
                                    let requests = urls.map(url => fetch(url));
                    
                                    // Promise.all waits until all jobs are resolved
                                    Promise.all(requests)
                                    .then(responses => responses.forEach(
                                        response => alert(`${response.url}: ${response.status}`)
                                    ));
                                </pre>
                                Any value that is not a promise itself, will be passed into the array of promises.
                                <pre>
                                    Promise.all([
                                        new Promise((resolve, reject) => {
                                            setTimeout(() => resolve(1), 1000)
                                        }),
                                        2,
                                        3
                                    ]).then(alert); // 1, 2, 3
                                </pre>
                            </li>
                            <li><code>Promise.allSettled([promises])</code> - returns an array of promises that is settled when all of the promises in the array are fulfilled or rejected. The other promises are not ignored even if one of them are rejected. All results are still shown in the array</li>
                            <li><code>Promise.race([promises])</code> - returns the first settled promise in the array</li>
                            <li><code>Promise.any([promises])</code> - returns the first fulfilled promise in the array. Should all the promises be rejected, the returned promise will be rejected with a AggregateError object that stores all promise errors in its <code>errors</code> property
                                <pre>
                                    Promise.any([
                                        new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ouch!")), 1000)),
                                        new Promise((resolve, reject) => setTimeout(() => reject(new Error("Error!")), 2000))
                                    ]).catch(error => {
                                        console.log(error.constructor.name); // AggregateError
                                        console.log(error.errors[0]); // Error: Ouch!
                                        console.log(error.errors[1]); // Error: Error!
                                    });
                                </pre>
                            </li>
                            <li><code>Promise.resolve(value)</code> - returns a resolved promise with the result of value. This is exactly the same as <code>new Promise(resolve => resolve(value))</li>
                            <li><code>Promise.reject(error)</code> - returns a rejected promise with the result of error. This is exactly the same as <code>new Promise((resolve, reject) => reject(error))</li>
                            <li>Promise.resolve() and Promise.reject() are mostly never used modernly, because we have async / await.</li>
                        </ul>
                    </li>
                    <li>Promisification - the process of converting a callback-based API into a promise-based API; It is meant for functions that call the callback once. It is useful as many functions and libraries are callback-based, so it makes sense to promisify them.
                        <pre>
                            function loadScript(src, callback) {
                                let script = document.createElement('script');
                                script.src = src;
                    
                                script.onload = () => callback(null, script);
                                script.onerror = () => callback(new Error(`Script load error for ${src}`));
                    
                                document.head.append(script);
                            }
                            //becomes...
                            let loadScriptPromise = function(src) {
                                return new Promise((resolve, reject) => {
                                  loadScript(src, (err, script) => {
                                    if (err) reject(err);
                                    else resolve(script);
                                  });
                                });
                            };
                        </pre>
                        We may need to promisify other functions as well, so it makes sense to make it a helper function. 
                        <pre>
                            function promisify(f) {
                                return function (...args) { // return a wrapper-function (*)
                                  return new Promise((resolve, reject) => {
                                    function callback(err, result) { // our custom callback for f (**)
                                        if (err) {
                                            reject(err);
                                        } else {
                                            resolve(result);
                                        }
                                    }
                              
                                    args.push(callback); // append our custom callback to the end of f arguments
                              
                                    f.call(this, ...args); // call the original function
                                  });
                                };
                            }
                              
                            // usage:
                            let loadScriptPromise = promisify(loadScript);
                            loadScriptPromise(...).then(...);
                        </pre>
                        If the callback needs more arguments we can improve the helper. If manyArgs is true, we return the promise that resolves with an array of callback results.
                        <pre>
                            // promisify(f, true) to get array of results
                            function promisify(f, manyArgs = false) {
                              return function (...args) {
                                return new Promise((resolve, reject) => {
                                  function callback(err, ...results) { // our custom callback for f
                                    if (err) {
                                      reject(err);
                                    } else {
                                      // resolve with all callback results if manyArgs is specified
                                      resolve(manyArgs ? results : results[0]);
                                    }
                                  }
                            
                                  args.push(callback);
                            
                                  f.call(this, ...args);
                                });
                              };
                            }
                            
                            // usage:
                            f = promisify(f, true);
                            f(...).then(arrayOfResults => ..., err => ...);                            
                        </pre>
                    </li>
                    <li>Microtasks
                        <ul>
                            <li>Promise handlers: then / catch / finally are ALWAYS ASYNCHRONOUS.</li>
                            <li>Even if the promise is immediately resolved, any code below these handles will still execute faster.</li>
                            <li>Because asynchronous tasks need to be executed, ECMA specifies a new event loop model known as the microtask queue (PromiseJobs). This queue is FIFO - first in, first out. When promises are ready, handlers are placed in a queue. Only when the javascript engine is no longer running the code inside it, the queue is accessed and executes the first task. </li>
                            <li>If there are multiple handlers each one is executed asynchronously, meaning the first gets queued and only executes when the other existing queued handlers are finished.This means handlers are executed in the order they are queued, making them synchronous but their operations themselves are asynchronous.</li>
                            <li>Microtasks represents the async part of the event loop.</li>
                            <li>In cases of unhandled rejections, the error is not being handled at the end of the microtask queue. The javascript engine will trigger the unhandledrejection event from the window object when the microqueue task is complete.
                                <pre>
                                    let promise = Promise.reject(new Error("Promise Failed!"));
                                    setTimeout(() => promise.catch(err => alert('caught')), 1000);
                                    // Promise Failed!
                                    window.addEventListener('unhandledrejection', event => alert(event.reason)); 

                                    //promise.reject() is read on the call stack and creates a rejected promise.
                                    //setTimeout() becomes an async timer handled by the browser
                                    //The unhandledrejection event is triggered on call stack and executes the code immediately. 
                                    //the timer is eventually done, so setTimeout is added to the macrotask queue.
                                    //the macrotask queue is added to the call stack which executes the code to push our catch() handler to the microtask queue. 
                                    //The event loop sends the catch() to the call stack and executes it finally. 
                                </pre>
                                In cases where there is a setTimeout(), this means the unhandledrejection event will be executed before the setTimeout is executed. Because setTimeout() has not been added to the microtask queue. 
                                setTimeout() is a callback based function. 
                            </li>
                            <li>setTimeout() is part of the macrotask queue / task queue. One the timer is done, it is sent to the task queue which means the event loop will check if the call stack is empty first, before executing setTimeout.</li>
                            <li>The event loop will always ensure the microtask queue is empty, before checkin the macrotask queue. After it does a macrotask, it will check again in the microtask. </li>
                            <li>Microtasks includes the promise callbacks like: then catch finally resolve reject, queueMicrotask, new MutationObserver, await</li>
                            <li>Macrotasks / task queue includes setTimeout, setInterval, and setImmediate</li>
                            <li>For fetch web api for example, this is whats happening: 
                                <pre>
                                    fetch('https://jsonplaceholder.typicode.com/users')
                                        .then(response => response.json())
                                    console.log('End of script');

                                    //Fetch is added to the call stack, then method, and finally the console.log
                                    //Once we get the promise state and result, then PromiseReaction handler is added to the microtask queue. So the then handler is being pushed to the microtask. 

                                    Promise.resolve()
                                        .then(() => console.log(1));
                                    
                                    setTimeout(() => console.log(2), 10);

                                    queueMicroTask(() => {
                                        console.log(3);
                                        queueMicrotask(() => console.log(4));
                                    })

                                    console.log(5);

                                    //This is whats called in order: 5 1 3 4 2

                                    //Promise.resolve() creates a new fulfilled / resolved promise object on the call stack
                                    //When then() is read by call stack it is added to the microtask queue
                                    //setTimeout is read by call stack to set a timer with webapi to do an async task of being a timer. 
                                    //queueMicroTask is added to the microtask queue
                                    //console.log(5) is added to the call stack, and executed
                                    //The 10 ms timer is up, and is pushed to the task queue. 
                                    //Since the event loop checked that the call stack is empty, it moves to the microtask queue first and finds, console.log(1).
                                    //The event loop also pushes the queueMicrotask handler to the call stack to empty out the microtask queue. So we console.log(3).
                                    //Since the code calls to queueMicrotask() again, we push that to the microtask queue. This callback is immediately pushed to the call stack by the event loop to ensure the microtask queue is empty.
                                    //Finally, we can move to the task queue, and the call stack executes the console.log(2).
                                </pre>
                            </li>
                        </ul>
                    </li>
                    <li>Async / Await
                        <ul>
                            <li>the <code>async</code> keyword before a function is used to create an asynchronous function, that returns a promise. Other values are wrapped in a resolved promise automatically.
                                <pre>
                                    async function f() {
                                        return 1;
                                      }
                                      
                                    f().then(alert); // 1
                                    //return is basically 'resolve' in promises

                                    so it can becomes 

                                    async function f() {
                                        return Promise.resolve(1);
                                    }
                                    f().then(alert);
                                </pre>
                            </li>
                            <li>Await makes javascript wait until promises settle and returns a result; it replaces .then() handlers
                                <pre>
                                    async function f() {

                                        let promise = new Promise((resolve, reject) => {
                                          setTimeout(() => resolve("done!"), 1000)
                                        });
                                      
                                        let result = await promise; // wait until the promise resolves (*)
                                      
                                        alert(result); // "done!"
                                    }
                                    
                                    f();
                                </pre>
                            </li>
                            <li>Modern browsers allow top-level await when were inside a module, meaning we don't require a async keyword to be used.
                                <pre>
                                    // we assume this code runs at top level, inside a module
                                    let response = await fetch('/article/promise-chaining/user.json');
                                    let user = await response.json();

                                    console.log(user);
                                </pre>
                            </li>
                            <li>Await accepts 'thenables'</li>
                            <li>To declare a async class method, just prepend it with async
                                <pre>
                                    class Waiter {
                                        async wait() {
                                            return await Promise.resolve(1);
                                        }
                                    }
                                      
                                    new Waiter()
                                        .wait()
                                        .then(alert); // 1 (this is the same as (result => alert(result)))
                                </pre>
                            </li>
                            <li>Error handling is different for async/await since theres no catch handler. It does however throw an error if the promise is rejected: 
                                <pre>
                                    async function f() {
                                        await Promise.reject(new Error("Whoops!"));
                                    }

                                    is the same as: 

                                    async function f() {
                                        throw new Error("Whoops!");
                                    }
                                </pre>

                                We can also use try/catch to handle errors in async/await

                                <pre>
                                    async function f() {
                                        try {
                                          let response = await fetch('/no-user-here');
                                          let user = await response.json();
                                        } catch(err) {
                                          // catches errors both in fetch and response.json
                                          alert(err);
                                        }
                                    }
                                    
                                    f();
                                </pre>

                                We can also append a catch handler to the async function itself as well: 

                                <pre>
                                    async function f() {
                                        let response = await fetch('http://no-such-url');
                                    }
                                    
                                    // f() becomes a rejected promise
                                    f().catch(alert); // TypeError: failed to fetch // (*)
                                </pre>
                            </li>
                        </ul>
                        <hr>
                        <ul>
                            <li style="list-style-type: none">Javascript Async Await Web Dev Simplified</li>
                            <li>Async / Await is syntactical sugar that makes writing asynchronous code much easier and replaces the use of promise handlers </li>
                            <li>It makes asynchronous code look synchronous.</li>
                            <li>If we want to catch an error, we can use the <code>try catch</code>
                                <pre>
                                    async function doWork(){
                                        try{
                                            const response = await makeRequest('Facebook')
                                            console.log('Response Received');
                                            const processedResponse = await processRequest(response);
                                            console.log('Processed Response');
                                        } catch(error){
                                            console.log(error);
                                        }
                                    }
                                </pre>
                            </li>
                        </ul>
                    </li>
                </ul>
            </fieldset>
        </fieldset>
        <fieldset id="class-34">
            <legend>Class 34 - Interviews</legend>
            <ul>
                Process:
                <li>Typically there are three ways that kick off the interview process: applying, recruited, and recommended by someone.</li>
                <li>Phone Screen (sniff test) </li>
                <li>Behavioral Interview - The Bank </li>
                <li>Technical Questions - The Bank </li>
                <li>Take Home - take home problems and submit it</li>
                <li>Whiteboard - coding challenge on whiteboard/online editor live coding</li>
                <li>In-person - in person interview</li>
                <li>Wine and Dine Interview</li>
                <li>Offer</li>

                <hr>

                <li>For behavior interviews, for every question, we can use the following: CAR - Cause Action Results</li>
                <li>Cause is what happened, Action is how it happened, and Results is why you are the best based on the actions you took.</li>
                <li>CAUSE - KEYWORD; At my last company... / At my last opportunity... (let them dig, no need to mention bootcamp at all or 100devs)</li>

                <hr>

                <li>For Technical interviews, for every question, we can use EUE</li>
                <li>EUE - Explanation, Use (purpose), Example (use case)</li>

                <hr>

                <li>Whiteboarding tests check for: communication and collaboration skills, job specific knowledge, survival abilities under pressure, and other whiteboarding skills... (They are not just looking for the answer)</li>
                <li>To get through coding challenges we can use PREP</li>
                <li>PREP - Parameters, Returns, Examples, Psuedo Code</li>
                <pre>
                    FIZZBUZZ
                    //A number 1 to number, return "fizz" if divisible by 3, "buzz" if divisible by 5, and "fizzbuzz" if divisible by both 3 and 5
                    //P: num, whole, + (positive)
                    //R: string, console.log
                    //E w/P: 
                    function fizzBuzz(num){
                        //loop
                        //conditionals %3&5, % 3, % 5
                        //console.log num or fizz, buzz, or fizzbuzz   
                    }

                    fizzBuzz(5) // 1, 2, fizz, 4, buzz
                    fizzBuzz(3) // 1, 2, fizz
                    fizzBuzz(15) // 1, 2, fizz, 4, buzz, fizz, 7, 8, fizz, buzz, 11, fizz, 13, 14, fizzbuzz

                    //make sure to ask the interview about the problem, so you understand it completely. 

                    //P : So ask the interviewer about the parameter we're using. In terms of this problem, is the parameter always a number for example? A whole number? negative? 

                    //R : What are we returning? 

                    //E: Confirm your test cases and function with your interviewer.

                    //We can now solve it

                    function fizzBuzz(num){
                        for(let i = 1; i <= num; i++){
                            if(i % 3 === 0 && i % 5 === 0){
                                console.log('fizzbuzz');
                            } else if(i % 3 === 0){
                                console.log('fizz');
                            } else if(i % 5 === 0){
                                console.log('buzz');
                            } else {
                                console.log(i);
                            }
                        }
                    }
                    or: 
                    const fizzBuzz = num => {
                        for(let i = 1; i <= num; i++){
                            console.log(i % 3 === 0 && i % 5 === 0 ? 'fizzbuzz' 
                            : i % 3 === 0 ? 'fizz' 
                            : i % 5 === 0 ? 'buzz' 
                            : i);
                        }
                    }

                </pre>
            </ul>
            <ul>
                <li>Hi, I'm currently not pursuing new opportunities at the moment, but i would love to reconnect in three months. Can we set up a time to talk three months from now?</li>
            </ul>
        </fieldset>
    </body>
</html>

